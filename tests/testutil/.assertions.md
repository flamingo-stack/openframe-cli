<!-- source-hash: bdc675d36ef86bda3cef458db0db0556 -->
A utility package providing fluent assertion methods for testing command line output with chainable operations.

## Key Components

- **AssertCommandOutput**: Main struct that wraps command execution results (stdout, stderr, error) with fluent assertion methods
- **NewAssertCommandOutput**: Factory function to create assertion instances for command testing
- **Error Assertions**: `NoError()`, `HasError()`, `ErrorContains()` for validating command execution status
- **Output Assertions**: `StdoutContains()`, `StderrContains()`, `OutputContains()` for validating command output content
- **Batch Assertions**: `ContainsAll()`, `StderrContainsAny()` for multiple text validation
- **Empty State Assertions**: `StdoutEmpty()`, `StderrEmpty()` for validating clean output
- **Helper Functions**: `AssertCommandSuccess()` and `AssertCommandFailure()` for common test patterns

## Usage Example

```go
func TestMyCommand(t *testing.T) {
    // Execute some command that returns stdout, stderr, err
    stdout, stderr, err := executeCommand("myapp", "list", "--verbose")
    
    // Chain assertions for successful command
    NewAssertCommandOutput(t, stdout, stderr, err).
        NoError().
        StderrEmpty().
        StdoutContains("Processing complete").
        ContainsAll("item1", "item2", "item3")
    
    // Use helper for common patterns
    AssertCommandSuccess(t, stdout, stderr, err).
        StdoutContains("Success")
    
    // Test failure scenarios
    stdout2, stderr2, err2 := executeCommand("myapp", "invalid")
    AssertCommandFailure(t, stdout2, stderr2, err2).
        StderrContainsAny("error", "failed", "invalid")
}
```