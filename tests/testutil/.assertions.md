<!-- source-hash: bdc675d36ef86bda3cef458db0db0556 -->
Provides a fluent interface for asserting command execution results in tests, offering chainable methods to verify stdout, stderr, and error conditions.

## Key Components

- **AssertCommandOutput**: Main struct containing test context and command output data
- **NewAssertCommandOutput()**: Constructor for creating new assertion instances
- **Error Assertions**: `NoError()`, `HasError()`, `ErrorContains()` for validating error states
- **Output Assertions**: `StdoutContains()`, `StderrContains()`, `OutputContains()` for content validation
- **Empty Checks**: `StdoutEmpty()`, `StderrEmpty()` for verifying no output
- **Convenience Functions**: `AssertCommandSuccess()`, `AssertCommandFailure()` for common patterns

## Usage Example

```go
func TestCommandExecution(t *testing.T) {
    // Test successful command
    stdout, stderr, err := executeCommand("ls", "-la")
    
    // Chain multiple assertions fluently
    NewAssertCommandOutput(t, stdout, stderr, err).
        NoError().
        StdoutContains("total").
        StderrEmpty()
    
    // Use convenience function for common success pattern
    AssertCommandSuccess(t, stdout, stderr, err).
        ContainsAll("file1.txt", "file2.txt")
    
    // Test command failure
    stdout, stderr, err = executeCommand("invalid-command")
    
    AssertCommandFailure(t, stdout, stderr, err).
        StderrContainsAny("command not found", "not recognized")
}
```