<!-- source-hash: 605c05f61ca8a46b1ba11271e680b67f -->
A testing utility package that provides automated building and execution of CLI binaries for integration testing with intelligent caching and project root detection.

## Key Components

- **`InitializeCLI()`** - Builds the CLI binary with smart caching (only rebuilds if source is newer)
- **`CleanupCLI()`** - Removes the built CLI binary and cleans up state
- **`GetProjectRoot()`** - Automatically discovers the project root directory by finding `go.mod`
- **`RunCLI(args ...string)`** - Executes the CLI binary with specified arguments and captures output
- **`CLIResult`** - Structured result containing stdout, stderr, exit code, and error information
- **Result Helper Methods** - `Success()`, `Failed()`, `Output()`, `ErrorMessage()` for convenient result analysis

## Usage Example

```go
// Initialize and build the CLI binary
err := InitializeCLI()
if err != nil {
    log.Fatalf("Failed to initialize CLI: %v", err)
}
defer CleanupCLI()

// Run CLI commands and check results
result := RunCLI("version")
if result.Success() {
    fmt.Printf("CLI version: %s", result.Stdout)
} else {
    fmt.Printf("Command failed: %s", result.ErrorMessage())
}

// Run command with multiple arguments
result = RunCLI("deploy", "--config", "test.yaml")
if result.Failed() {
    fmt.Printf("Deploy failed with exit code %d: %s", 
        result.ExitCode, result.ErrorMessage())
}
```

This package is designed for integration tests where you need to execute the actual CLI binary and verify its behavior, with efficient binary management and comprehensive output capture.