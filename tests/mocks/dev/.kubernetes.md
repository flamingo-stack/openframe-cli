<!-- source-hash: 73103c75e6567159b9df108171067ca9 -->
A mock implementation of a Kubernetes client designed for testing UI components and development workflows. It provides simulated Kubernetes cluster data including namespaces and services without requiring an actual cluster connection.

## Key Components

- **MockKubernetesClient**: Main mock client struct with configurable failure modes
- **NewMockKubernetesClient()**: Factory function that creates a client with sample data
- **Namespace operations**: `GetNamespaces()`, `ValidateNamespace()`, `AddNamespace()`
- **Service operations**: `GetServices()`, `GetService()`, `ValidateService()`, `AddService()`
- **Test utilities**: Methods to simulate failures and manipulate mock state
- **Filtering**: `GetServicesByType()` for filtering services by type

## Usage Example

```go
// Create mock client with sample data
client := NewMockKubernetesClient()

// Get available namespaces
namespaces, err := client.GetNamespaces(context.Background())
if err != nil {
    log.Fatal(err)
}

// Get services in a namespace
services, err := client.GetServices(context.Background(), "default")
if err != nil {
    log.Fatal(err)
}

// Add custom test data
client.AddNamespace("test-env")
client.AddService("test-env", intercept.ServiceInfo{
    Name:      "test-api",
    Namespace: "test-env",
    Type:      "ClusterIP",
    Ports:     []intercept.ServicePort{{Port: 8080}},
})

// Simulate failures for error handling tests
client.SetShouldFailNamespaces(true)
_, err = client.GetNamespaces(context.Background())
// err will be non-nil
```

The mock comes pre-populated with realistic data across multiple namespaces (default, production, staging, development) and various service configurations for comprehensive testing scenarios.