<!-- source-hash: 4715ded5ad318c605c52a66b5e4b0e60 -->
This file provides functionality for waiting and monitoring ArgoCD application synchronization during installation with robust cancellation handling and progress reporting.

## Key Components

### Main Function
- **`WaitForApplications(ctx, config)`** - Main function that waits for all ArgoCD applications to reach Healthy and Synced status with timeout, cancellation, and progress monitoring

### Core Features
- **Bootstrap Phase** - 30-second initial wait period for applications to be created
- **Progress Monitoring** - Real-time tracking of application health and sync status
- **Signal Handling** - Graceful handling of Ctrl+C and SIGTERM signals
- **Spinner UI** - Visual progress indicator with timer and percentage completion
- **Verbose Logging** - Detailed status reporting for troubleshooting
- **Timeout Management** - 60-minute maximum wait with early exit conditions

### State Tracking
- **Ever-Ready Apps** - Tracks applications that have achieved ready status to prevent regression counting
- **Application Parsing** - Monitors application health, sync status, and deployment progress
- **Debug Information** - Pod-level troubleshooting for stuck applications after 7 minutes

## Usage Example

```go
// Initialize ArgoCD manager
manager := &Manager{
    executor: commandExecutor,
}

// Configure installation
config := config.ChartInstallConfig{
    DryRun:  false,
    Verbose: true,
    Silent:  false,
}

// Wait for applications with context and cancellation
ctx, cancel := context.WithTimeout(context.Background(), 60*time.Minute)
defer cancel()

err := manager.WaitForApplications(ctx, config)
if err != nil {
    log.Fatalf("ArgoCD application wait failed: %v", err)
}
```

The function handles dry-run mode, context cancellation, signal interrupts, and provides comprehensive progress feedback for ArgoCD application deployments.