<!-- source-hash: cc1feeb642f8578eaa85e6c6b37561fe -->
Implements retry policies and execution logic for handling recoverable errors with exponential and linear backoff strategies. The package provides configurable retry mechanisms with jitter, context cancellation support, and predefined policies for common scenarios.

## Key Components

- **RetryPolicy Interface**: Defines retry behavior with `ShouldRetry()`, `GetDelay()`, and `GetMaxAttempts()` methods
- **ExponentialBackoffPolicy**: Implements exponential backoff with configurable multiplier, jitter, and max delay
- **LinearBackoffPolicy**: Implements linear delay increase with fixed increment
- **RetryExecutor**: Executes operations with retry logic, supporting both simple functions and functions returning results
- **RecoverableError Interface**: Allows errors to self-identify as retryable with custom retry delays
- **Predefined Policies**: NetworkRetryPolicy, ResourceRetryPolicy, and InstallationRetryPolicy for common use cases
- **Callback Functions**: DefaultRetryCallback, QuietRetryCallback, and VerboseRetryCallback for retry logging

## Usage Example

```go
// Create retry executor with exponential backoff
policy := NewExponentialBackoffPolicy(5, 2*time.Second)
executor := NewRetryExecutor(policy).
    WithRetryCallback(DefaultRetryCallback("API call"))

// Execute operation with retries
ctx := context.Background()
err := executor.Execute(ctx, func() error {
    return makeNetworkCall()
})

// Execute with result
result, err := executor.ExecuteWithResult(ctx, func() (interface{}, error) {
    return fetchData(), nil
})

// Use predefined policy
networkExecutor := NewRetryExecutor(NetworkRetryPolicy())
```