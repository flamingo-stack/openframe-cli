<!-- source-hash: cc1feeb642f8578eaa85e6c6b37561fe -->
Provides flexible retry policies and execution strategies for handling recoverable errors with exponential and linear backoff algorithms. Includes predefined policies for common scenarios like network operations, resource availability, and installations.

## Key Components

**Interfaces:**
- `RetryPolicy` - Defines retry behavior (should retry, delay calculation, max attempts)
- `RecoverableError` - Interface for errors that can indicate their retry eligibility

**Retry Policies:**
- `ExponentialBackoffPolicy` - Exponential delay increase with jitter and configurable retryable errors
- `LinearBackoffPolicy` - Linear delay increase for simpler retry scenarios

**Execution:**
- `RetryExecutor` - Handles retry logic with context support and optional callbacks
- `DefaultRetryCallback`, `QuietRetryCallback`, `VerboseRetryCallback` - Predefined logging strategies

**Predefined Policies:**
- `NetworkRetryPolicy()`, `ResourceRetryPolicy()`, `InstallationRetryPolicy()` - Common use case configurations

## Usage Example

```go
// Basic exponential backoff retry
policy := NewExponentialBackoffPolicy(3, 1*time.Second)
executor := NewRetryExecutor(policy).WithRetryCallback(DefaultRetryCallback("API call"))

err := executor.Execute(ctx, func() error {
    return makeAPICall()
})

// Using predefined network policy
networkExecutor := NewRetryExecutor(NetworkRetryPolicy())
result, err := networkExecutor.ExecuteWithResult(ctx, func() (interface{}, error) {
    return httpClient.Get("https://api.example.com")
})

// Custom recoverable error
type MyError struct {
    recoverable bool
}

func (e *MyError) IsRecoverable() bool { return e.recoverable }
func (e *MyError) GetRetryAfter() time.Duration { return 5*time.Second }
func (e *MyError) Error() string { return "custom error" }
```