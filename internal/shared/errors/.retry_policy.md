<!-- source-hash: cc1feeb642f8578eaa85e6c6b37561fe -->
Provides a comprehensive retry mechanism with configurable policies and backoff strategies for handling recoverable errors in distributed systems and network operations.

## Key Components

**Interfaces:**
- `RetryPolicy` - Defines retry behavior contract with attempt limits and delay calculation
- `RecoverableError` - Interface for errors that can determine their own retry eligibility

**Retry Policies:**
- `ExponentialBackoffPolicy` - Implements exponential backoff with jitter and configurable error patterns
- `LinearBackoffPolicy` - Implements linear delay increases for simpler retry scenarios

**Executor:**
- `RetryExecutor` - Orchestrates retry logic with context cancellation and callback support
- `Execute()` - Retries operations without return values
- `ExecuteWithResult()` - Retries operations with return values

**Predefined Policies:**
- `NetworkRetryPolicy()` - Optimized for network timeouts and connection issues
- `ResourceRetryPolicy()` - Designed for resource availability scenarios
- `InstallationRetryPolicy()` - Tailored for Helm/installation operations

## Usage Example

```go
// Create retry executor with exponential backoff
policy := NewExponentialBackoffPolicy(5, 2*time.Second)
executor := NewRetryExecutor(policy).WithRetryCallback(DefaultRetryCallback("API call"))

// Retry a network operation
err := executor.Execute(ctx, func() error {
    return makeAPICall()
})

// Retry with result
result, err := executor.ExecuteWithResult(ctx, func() (interface{}, error) {
    return fetchData()
})

// Use predefined policy for network operations
networkExecutor := NewRetryExecutor(NetworkRetryPolicy())
err = networkExecutor.Execute(ctx, networkOperation)
```