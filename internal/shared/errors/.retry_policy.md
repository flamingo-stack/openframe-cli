<!-- source-hash: cc1feeb642f8578eaa85e6c6b37561fe -->
Implements robust retry mechanisms with configurable backoff strategies for handling transient errors in distributed systems and network operations.

## Key Components

### Interfaces
- **`RetryPolicy`** - Defines retry behavior with attempt limits and delay calculation
- **`RecoverableError`** - Interface for errors that indicate retry feasibility

### Policy Implementations
- **`ExponentialBackoffPolicy`** - Exponential delay increases with jitter to prevent thundering herd
- **`LinearBackoffPolicy`** - Linear delay increases for predictable retry timing

### Execution Framework
- **`RetryExecutor`** - Core retry orchestrator with context cancellation support
- **Built-in Callbacks** - `DefaultRetryCallback`, `QuietRetryCallback`, `VerboseRetryCallback` for different logging levels

### Predefined Policies
- **`NetworkRetryPolicy()`** - Optimized for network timeouts and connection failures
- **`ResourceRetryPolicy()`** - Designed for resource availability and cluster readiness
- **`InstallationRetryPolicy()`** - Tuned for deployment and installation operations

## Usage Example

```go
// Basic exponential backoff with custom operation
policy := NewExponentialBackoffPolicy(3, 2*time.Second)
executor := NewRetryExecutor(policy).
    WithRetryCallback(DefaultRetryCallback("database connection"))

err := executor.Execute(ctx, func() error {
    return database.Connect()
})

// Using predefined policy for network operations
networkExecutor := NewRetryExecutor(NetworkRetryPolicy())
result, err := networkExecutor.ExecuteWithResult(ctx, func() (interface{}, error) {
    resp, err := http.Get("https://api.example.com/data")
    if err != nil {
        return nil, err
    }
    return resp, nil
})

// Custom recoverable error
type DatabaseError struct {
    Message string
    Retryable bool
}

func (e DatabaseError) Error() string { return e.Message }
func (e DatabaseError) IsRecoverable() bool { return e.Retryable }
func (e DatabaseError) GetRetryAfter() time.Duration { return 5 * time.Second }
```