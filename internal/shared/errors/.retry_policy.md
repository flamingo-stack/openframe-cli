<!-- source-hash: cc1feeb642f8578eaa85e6c6b37561fe -->
Provides comprehensive retry policies and execution logic for handling transient errors with configurable backoff strategies and context-aware cancellation support. The file implements exponential and linear backoff policies with built-in error classification and jitter to prevent thundering herd problems.

## Key Components

- **RetryPolicy** - Interface defining retry behavior with attempt limits and delay calculations
- **RecoverableError** - Interface for errors that can be retried with custom retry timing
- **ExponentialBackoffPolicy** - Implements exponential backoff with configurable jitter and error classification
- **LinearBackoffPolicy** - Simple linear delay increase for each retry attempt
- **RetryExecutor** - Main execution engine with context cancellation and callback support
- **Predefined Policies** - NetworkRetryPolicy, ResourceRetryPolicy, and InstallationRetryPolicy for common scenarios
- **Callback Functions** - DefaultRetryCallback, QuietRetryCallback, and VerboseRetryCallback for logging

## Usage Example

```go
// Create a network retry policy and executor
policy := NetworkRetryPolicy()
executor := NewRetryExecutor(policy).
    WithRetryCallback(DefaultRetryCallback("API call"))

// Execute operation with retries
err := executor.Execute(ctx, func() error {
    return makeAPICall()
})

// Execute operation returning a result
result, err := executor.ExecuteWithResult(ctx, func() (interface{}, error) {
    return fetchData()
})

// Custom exponential backoff policy
customPolicy := NewExponentialBackoffPolicy(5, 1*time.Second)
customPolicy.MaxDelay = 30 * time.Second
customPolicy.Jitter = true

executor = NewRetryExecutor(customPolicy)
err = executor.Execute(ctx, func() error {
    return performOperation()
})
```

The retry system automatically classifies errors as retryable based on error messages and interfaces, applies appropriate delays with optional jitter, and respects context cancellation for clean shutdown behavior.