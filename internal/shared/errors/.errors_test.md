<!-- source-hash: 0bcf456aac2eb6a80794da7d1c831d1a -->
This file contains comprehensive unit tests for a custom Go errors package, covering custom error types and error handling functionality.

## Key Components

- **ValidationError Tests**: Tests for field validation errors with custom formatting
- **CommandError Tests**: Tests for command execution errors with argument handling and error wrapping
- **ErrorHandler Tests**: Tests for error handling functionality with verbose/non-verbose modes
- **Utility Functions**: Tests for error creation and type checking functions
- **Edge Cases**: Tests covering empty fields, special characters, and nil handling
- **Benchmarks**: Performance tests for error string generation

## Usage Example

```go
// Test ValidationError formatting
func TestValidationError_Error(t *testing.T) {
    err := &ValidationError{
        Field:   "name",
        Value:   "invalid-name",
        Message: "must contain only letters",
    }
    expected := "validation failed for name 'invalid-name': must contain only letters"
    assert.Equal(t, expected, err.Error())
}

// Test CommandError with unwrapping
func TestCommandError_Unwrap(t *testing.T) {
    originalErr := errors.New("original error")
    cmdErr := &CommandError{
        Command: "kubectl",
        Args:    []string{"get", "pods"},
        Err:     originalErr,
    }
    assert.True(t, errors.Is(cmdErr, originalErr))
}

// Test error type checking
func TestIsValidationError(t *testing.T) {
    err := &ValidationError{Field: "test", Message: "test"}
    assert.True(t, IsValidationError(err))
}
```

The tests ensure proper error formatting, type assertion, error wrapping/unwrapping, and handler functionality across different scenarios.