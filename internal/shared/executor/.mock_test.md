<!-- source-hash: 8361fce1efa2cd457ee8a67925ea2da6 -->
This test file provides comprehensive testing for a mock command executor implementation used for testing command execution functionality without running actual system commands.

## Key Components

- **NewMockCommandExecutor Tests**: Validates proper initialization and interface compliance
- **Execute Method Tests**: Tests command execution with various scenarios including default responses, custom responses, and failure conditions
- **ExecuteWithOptions Tests**: Verifies execution with structured options including environment variables and timeouts
- **Response Management Tests**: Tests `SetResponse()` and `SetDefaultResult()` for customizing mock behavior
- **Command Tracking Tests**: Validates methods like `GetExecutedCommands()`, `GetCommandCount()`, `WasCommandExecuted()`, and `GetLastCommand()`
- **Pattern Matching Tests**: Tests substring matching for command responses
- **Edge Cases & Concurrency**: Handles empty commands, concurrent access, and zero-value results
- **Benchmarks**: Performance testing for execute and response operations

## Usage Example

```go
func TestMyService(t *testing.T) {
    // Create mock executor
    mockExec := NewMockCommandExecutor()
    
    // Configure specific response
    mockExec.SetResponse("git status", &CommandResult{
        ExitCode: 0,
        Stdout:   "clean working tree",
        Duration: 100 * time.Millisecond,
    })
    
    // Configure failure case
    mockExec.SetShouldFail(true, "network error")
    
    // Use in service under test
    service := NewMyService(mockExec)
    err := service.CheckGitStatus()
    
    // Verify execution
    assert.True(t, mockExec.WasCommandExecuted("git status"))
    assert.Equal(t, 1, mockExec.GetCommandCount())
}
```