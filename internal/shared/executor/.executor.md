<!-- source-hash: 7bbadf5e4f9688d6f0b9ea11b1951768 -->
Provides an abstraction layer for executing external system commands with support for timeouts, custom environments, dry-run mode, and detailed result capture. The package includes interfaces for dependency injection and testing.

## Key Components

- **`CommandExecutor`** - Interface for command execution with two methods: `Execute()` and `ExecuteWithOptions()`
- **`RealCommandExecutor`** - Concrete implementation that executes actual system commands
- **`CommandResult`** - Struct containing execution results (exit code, stdout, stderr, duration)
- **`ExecuteOptions`** - Configuration struct for advanced command execution (working directory, environment variables, timeout)
- **`NewRealCommandExecutor()`** - Factory function to create executor instances with dry-run and verbose options

## Usage Example

```go
package main

import (
    "context"
    "time"
)

func main() {
    // Create executor with dry-run disabled and verbose logging enabled
    executor := NewRealCommandExecutor(false, true)
    
    // Simple command execution
    result, err := executor.Execute(context.Background(), "ls", "-la")
    if err != nil {
        panic(err)
    }
    
    // Advanced execution with options
    options := ExecuteOptions{
        Command: "git",
        Args:    []string{"status"},
        Dir:     "/path/to/repo",
        Env:     map[string]string{"GIT_CONFIG": "/custom/config"},
        Timeout: 30 * time.Second,
    }
    
    result, err = executor.ExecuteWithOptions(context.Background(), options)
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Exit code: %d, Duration: %v\n", result.ExitCode, result.Duration)
    fmt.Printf("Output: %s\n", result.Output())
}
```