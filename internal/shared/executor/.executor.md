<!-- source-hash: 7bbadf5e4f9688d6f0b9ea11b1951768 -->
Provides an abstraction layer for executing external system commands with support for testing, dry-run mode, and detailed execution control. The package implements the command pattern with a testable interface for dependency injection.

## Key Components

- **CommandExecutor** - Interface for command execution abstraction
- **RealCommandExecutor** - Concrete implementation that executes actual system commands  
- **CommandResult** - Struct containing execution results (exit code, stdout/stderr, duration)
- **ExecuteOptions** - Configuration struct for fine-grained command execution control
- **NewRealCommandExecutor()** - Factory function creating executor with dry-run and verbose options

## Usage Example

```go
// Create executor with dry-run disabled and verbose logging enabled
executor := NewRealCommandExecutor(false, true)

// Simple command execution
ctx := context.Background()
result, err := executor.Execute(ctx, "ls", "-la", "/tmp")
if err != nil {
    log.Fatal(err)
}
fmt.Printf("Exit code: %d\n", result.ExitCode)
fmt.Printf("Output: %s\n", result.Stdout)

// Advanced execution with options
options := ExecuteOptions{
    Command: "make",
    Args:    []string{"build"},
    Dir:     "/path/to/project",
    Env:     map[string]string{"CGO_ENABLED": "0"},
    Timeout: 30 * time.Second,
}
result, err = executor.ExecuteWithOptions(ctx, options)
```