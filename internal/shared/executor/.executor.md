<!-- source-hash: 7bbadf5e4f9688d6f0b9ea11b1951768 -->
A comprehensive command execution abstraction layer that provides a clean interface for running external system commands with support for dry-run mode, verbose logging, timeouts, and custom environments. The executor is designed with dependency injection in mind to enable easy testing and mocking.

## Key Components

- **`CommandExecutor`** - Interface for executing commands with two methods: basic `Execute` and advanced `ExecuteWithOptions`
- **`CommandResult`** - Struct containing execution results including exit code, stdout/stderr output, and execution duration
- **`ExecuteOptions`** - Configuration struct for advanced execution control (working directory, environment variables, timeout)
- **`RealCommandExecutor`** - Concrete implementation that executes actual system commands with dry-run and verbose options
- **`NewRealCommandExecutor()`** - Factory function for creating executor instances

## Usage Example

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func main() {
    // Create executor with verbose logging, no dry-run
    executor := NewRealCommandExecutor(false, true)
    
    // Simple command execution
    result, err := executor.Execute(context.Background(), "ls", "-la")
    if err != nil {
        fmt.Printf("Error: %v\n", err)
        return
    }
    
    // Advanced execution with custom options
    options := ExecuteOptions{
        Command: "git",
        Args:    []string{"status"},
        Dir:     "/path/to/repo",
        Env:     map[string]string{"GIT_CONFIG": "/custom/config"},
        Timeout: 30 * time.Second,
    }
    
    result, err = executor.ExecuteWithOptions(context.Background(), options)
    if err != nil {
        fmt.Printf("Git command failed: %v\n", err)
        return
    }
    
    fmt.Printf("Exit Code: %d\n", result.ExitCode)
    fmt.Printf("Duration: %v\n", result.Duration)
    fmt.Printf("Output:\n%s\n", result.Output())
}
```