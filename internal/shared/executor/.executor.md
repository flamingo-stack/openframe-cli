<!-- source-hash: c6a21fb0249a7c28e96174e8c5213943 -->
This file provides a robust command execution abstraction layer with specialized Windows Subsystem for Linux (WSL) support, designed for cross-platform deployment tools that need to run commands in both native environments and WSL.

## Key Components

### WSL Management
- **WSLError**: Custom error type with operation context, exit codes, and helpful suggestions
- **IsWSLAvailable()**: Cached availability check for WSL on Windows systems
- **IsWSLUbuntuAvailable()**: Specific check for Ubuntu distribution accessibility
- **WakeUpWSL()**: Proactive WSL responsiveness check before critical operations
- **TryRecoverWSL()**: Last-resort WSL recovery through termination and restart
- **RestartDockerInWSL()**: Docker daemon restart within WSL after recovery

### Command Execution Interface
- **CommandExecutor**: Abstract interface for dependency injection and testing
- **RealCommandExecutor**: Production implementation with dry-run and verbose modes
- **CommandResult**: Structured result with exit code, output streams, and execution duration
- **ExecuteOptions**: Fine-grained execution control (working directory, environment, timeout)

### Constants
- **WSLExitCodeDistroNotFound**: 4294967295 (indicates WSL distribution not accessible)
- **WSLExitCodeGenericError**: 1 (generic WSL operation failure)

## Usage Example

```go
// Create command executor with verbose logging
executor := NewRealCommandExecutor(false, true)

// Simple command execution
ctx := context.Background()
result, err := executor.Execute(ctx, "kubectl", "get", "pods")
if err != nil {
    if wslErr, ok := err.(*WSLError); ok {
        fmt.Printf("WSL Error: %s\n", wslErr.Error())
        fmt.Printf("Suggestion: %s\n", wslErr.Suggestion)
        
        // Attempt WSL recovery
        if err := TryRecoverWSL(); err != nil {
            log.Fatalf("WSL recovery failed: %v", err)
        }
    }
    return err
}

// Advanced execution with options
options := ExecuteOptions{
    Command: "helm",
    Args:    []string{"install", "app", "./chart"},
    Dir:     "/path/to/charts",
    Env:     map[string]string{"KUBECONFIG": "/custom/config"},
    Timeout: 5 * time.Minute,
}
result, err := executor.ExecuteWithOptions(ctx, options)
```