<!-- source-hash: 7bbadf5e4f9688d6f0b9ea11b1951768 -->
This package provides a flexible abstraction layer for executing external system commands with support for dry-run mode, verbose logging, and comprehensive execution options.

## Key Components

- **`CommandExecutor`** - Interface for command execution with dependency injection support
- **`RealCommandExecutor`** - Concrete implementation that executes actual system commands
- **`CommandResult`** - Struct containing execution results (exit code, stdout/stderr, duration)
- **`ExecuteOptions`** - Configuration struct for advanced execution control (working directory, environment variables, timeouts)
- **`NewRealCommandExecutor()`** - Factory function to create executor instances

## Usage Example

```go
// Create executor with dry-run and verbose modes
executor := NewRealCommandExecutor(false, true)

// Simple command execution
ctx := context.Background()
result, err := executor.Execute(ctx, "git", "status")
if err != nil {
    log.Fatal(err)
}
fmt.Printf("Exit code: %d\n", result.ExitCode)
fmt.Printf("Output: %s\n", result.Stdout)

// Advanced execution with options
options := ExecuteOptions{
    Command: "npm",
    Args:    []string{"install"},
    Dir:     "/path/to/project",
    Env:     map[string]string{"NODE_ENV": "production"},
    Timeout: 5 * time.Minute,
}
result, err = executor.ExecuteWithOptions(ctx, options)
```

The interface design enables easy mocking for unit tests while providing rich execution metadata and error handling.