<!-- source-hash: 7bbadf5e4f9688d6f0b9ea11b1951768 -->
Provides a flexible abstraction layer for executing system commands with support for dry-run mode, custom environments, timeouts, and comprehensive result tracking. The interface allows for easy testing and dependency injection.

## Key Components

- **CommandExecutor** - Interface defining command execution methods
- **RealCommandExecutor** - Concrete implementation using `os/exec`
- **CommandResult** - Struct containing execution results (exit code, output, duration)
- **ExecuteOptions** - Configuration struct for advanced command execution
- **NewRealCommandExecutor()** - Constructor with dry-run and verbose options

## Usage Example

```go
// Create executor with dry-run and verbose logging
executor := NewRealCommandExecutor(false, true)

// Simple command execution
ctx := context.Background()
result, err := executor.Execute(ctx, "ls", "-la")
if err != nil {
    log.Fatal(err)
}
fmt.Printf("Exit code: %d\nOutput: %s\n", result.ExitCode, result.Stdout)

// Advanced execution with options
options := ExecuteOptions{
    Command: "docker",
    Args:    []string{"run", "--rm", "alpine", "echo", "hello"},
    Dir:     "/tmp",
    Env:     map[string]string{"DEBUG": "1"},
    Timeout: 30 * time.Second,
}
result, err = executor.ExecuteWithOptions(ctx, options)
```

The executor handles timeouts, working directories, environment variables, and provides detailed logging in verbose mode. Dry-run mode allows testing command sequences without actual execution.