<!-- source-hash: a30b19537539542cb9cf4f01335a6ec6 -->
MockCommandExecutor provides a test implementation of the CommandExecutor interface that simulates command execution without running actual external commands. It's designed for unit testing and allows complete control over command responses and behavior.

## Key Components

- **MockCommandExecutor**: Main struct that implements CommandExecutor interface
- **NewMockCommandExecutor()**: Factory function that creates a new mock instance
- **SetShouldFail()**: Configures the mock to simulate command failures
- **SetResponse()**: Sets specific responses for command patterns
- **Execute()/ExecuteWithOptions()**: Core execution methods that return mock results
- **GetExecutedCommands()**: Returns logged commands for test verification
- **Reset()**: Clears all state for test cleanup

## Usage Example

```go
// Create a mock executor for testing
mock := NewMockCommandExecutor()

// Configure specific responses
mock.SetResponse("git status", &CommandResult{
    ExitCode: 0,
    Stdout:   "On branch main\nnothing to commit",
    Duration: 50 * time.Millisecond,
})

// Configure failure simulation
mock.SetShouldFail(true, "network timeout")

// Execute commands in tests
result, err := mock.Execute(context.Background(), "git", "status")

// Verify commands were executed
assert.True(t, mock.WasCommandExecuted("git status"))
assert.Equal(t, 1, mock.GetCommandCount())

// Clean up for next test
mock.Reset()
```

The mock executor logs all executed commands, supports pattern-based response matching, and can simulate both successful and failed command executions, making it ideal for testing command-dependent code without external dependencies.