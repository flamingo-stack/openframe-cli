<!-- source-hash: a30b19537539542cb9cf4f01335a6ec6 -->
A mock implementation of the CommandExecutor interface designed for unit testing, allowing simulation of command execution without running actual external processes.

## Key Components

### Types
- **`MockCommandExecutor`** - Main mock struct that implements CommandExecutor interface
- Fields for command logging, predefined responses, and failure simulation

### Core Methods
- **`NewMockCommandExecutor()`** - Creates a new mock executor with default settings
- **`Execute()`** - Simulates command execution with basic parameters
- **`ExecuteWithOptions()`** - Simulates command execution with extended options
- **`SetResponse()`** - Configures specific responses for command patterns
- **`SetShouldFail()`** - Enables failure simulation with custom error messages

### Testing Utilities
- **`GetExecutedCommands()`** - Returns log of all executed commands
- **`WasCommandExecuted()`** - Checks if a command pattern was executed
- **`GetCommandCount()`** - Returns total number of executed commands
- **`GetLastCommand()`** - Returns the most recently executed command
- **`Reset()`** - Clears all logged commands and responses

## Usage Example

```go
// Create mock executor for testing
mock := NewMockCommandExecutor()

// Configure specific response for git commands
mock.SetResponse("git status", &CommandResult{
    ExitCode: 0,
    Stdout:   "On branch main\nnothing to commit",
    Duration: 50 * time.Millisecond,
})

// Execute command
result, err := mock.Execute(context.Background(), "git", "status")

// Verify execution in tests
assert.True(t, mock.WasCommandExecuted("git status"))
assert.Equal(t, 1, mock.GetCommandCount())
assert.NoError(t, err)
assert.Equal(t, 0, result.ExitCode)
```