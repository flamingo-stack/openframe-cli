<!-- source-hash: ee63ccb2070e3492e1d03b1bdd2e2440 -->
A comprehensive progress tracking system for multi-step operations with visual feedback, step management, and cancellation support using pterm for terminal UI.

## Key Components

### Core Types
- **`Tracker`** - Main progress tracking coordinator with thread-safe operations
- **`Step`** - Individual operation step with status, timing, and error tracking
- **`StepStatus`** - Enumerated step states (Pending, Running, Completed, Failed, Skipped)

### Primary Methods
- **`NewTracker(operation, steps)`** - Creates tracker with cancellation context
- **`Start()`** - Begins operation with spinner display
- **`StartStep(index)`** - Transitions to specific step with status updates
- **`CompleteStep(index)`**, **`FailStep(index, err)`**, **`SkipStep(index, reason)`** - Step completion handlers
- **`UpdateProgress(percentage)`** - Updates weighted progress calculation
- **`Complete()`**, **`Fail(err)`**, **`Cancel()`** - Operation termination methods

### Monitoring Features
- **`GetProgress()`** - Returns weighted completion percentage
- **`GetEstimatedTimeRemaining()`** - Calculates ETA based on elapsed time
- **`Context()`** - Provides cancellation context for cooperative cancellation

## Usage Example

```go
// Define operation steps
steps := []Step{
    {Name: "Initialize", Description: "Setup environment", Weight: 1.0},
    {Name: "Download", Description: "Fetch resources", Weight: 3.0},
    {Name: "Process", Description: "Transform data", Weight: 2.0},
    {Name: "Finalize", Description: "Cleanup", Weight: 1.0},
}

// Create and start tracker
tracker := NewTracker("Data Processing", steps)
tracker.Start()

// Execute steps with progress tracking
for i, step := range steps {
    if err := tracker.StartStep(i); err != nil {
        tracker.Fail(err)
        return
    }
    
    // Simulate work with progress updates
    for progress := 0; progress <= 100; progress += 10 {
        tracker.UpdateProgress(float64(progress))
        time.Sleep(100 * time.Millisecond)
        
        // Check for cancellation
        select {
        case <-tracker.Context().Done():
            tracker.Cancel()
            return
        default:
        }
    }
    
    if err := doStepWork(step); err != nil {
        tracker.FailStep(i, err)
        tracker.Fail(err)
        return
    }
    
    tracker.CompleteStep(i)
}

tracker.Complete()
```