# Doc Orchestrator Pipeline
# ===========================
# This GitHub Actions workflow is triggered by the multi-platform-hub to generate
# comprehensive documentation for this repository and create a PR with the results.
#
# 3-Stage Pipeline:
# 1. Inline Documentation - Generate .md files next to source classes
# 2. CodeWiki Analysis - Architecture overview and Mermaid diagrams
# 3. VoltAgent Tutorials - AI-generated getting started and how-to guides
#
# Installation:
# Copy this file to .github/workflows/doc-orchestrator.yml in your target repository.
# No secrets required - all credentials are securely passed from the orchestrator at runtime.

name: Doc Orchestrator Pipeline

on:
  # Push trigger - registers workflow with GitHub Actions (required for workflow_dispatch API)
  # Only triggers when the workflow file itself is modified (runs once on initial setup)
  push:
    paths:
      - '.github/workflows/doc-orchestrator.yml'

  repository_dispatch:
    types: [doc-orchestrator]

  workflow_dispatch:
    inputs:
      run_id:
        description: 'Run ID for tracking'
        required: false
        default: 'manual'
      repo_id:
        description: 'Repository ID in orchestrator database'
        required: false
        default: ''
      callback_url:
        description: 'Webhook URL for completion callback'
        required: false
        default: ''
      stages:
        description: 'Comma-separated stages to run (inline-docs,codewiki,voltagent)'
        required: false
        default: 'inline-docs,codewiki,voltagent'
      dependencies:
        description: 'Comma-separated dependency repos'
        required: false
        default: ''
      source_branch:
        description: 'Branch to analyze code from (defaults to main)'
        required: false
        default: 'main'
      anthropic_api_key:
        description: 'Anthropic API key for AI processing (Stage 1 & 3)'
        required: false
        default: ''
      openai_api_key:
        description: 'OpenAI API key for CodeWiki (Stage 2) - CodeWiki only supports OpenAI provider'
        required: false
        default: ''
      webhook_secret:
        description: 'Secret for webhook authentication'
        required: false
        default: ''
      github_pat:
        description: 'GitHub PAT for cross-repo access (optional, for private dependencies)'
        required: false
        default: ''
      inline_docs_limit:
        description: 'Max files per folder for inline docs (0=unlimited, useful for testing)'
        required: false
        default: '0'

permissions:
  contents: write
  pull-requests: write

env:
  # SECURITY: Only NON-SENSITIVE variables in job-level env
  # Secrets are passed per-step to avoid exposure in job setup logs
  # Run configuration (non-sensitive)
  RUN_ID: ${{ github.event.client_payload.run_id || github.event.inputs.run_id || github.run_id }}
  REPO_ID: ${{ github.event.client_payload.repo_id || github.event.inputs.repo_id || '' }}
  CALLBACK_URL: ${{ github.event.client_payload.callback_url || github.event.inputs.callback_url || '' }}
  STAGES: ${{ github.event.client_payload.stages || github.event.inputs.stages || 'inline-docs,codewiki,voltagent' }}
  DEPENDENCIES: ${{ github.event.client_payload.dependencies || github.event.inputs.dependencies || '' }}
  # Branch to checkout for code analysis (github_branch from repo config)
  SOURCE_BRANCH: ${{ github.event.client_payload.source_branch || github.event.inputs.source_branch || 'main' }}
  # Debug/testing: limit files per folder for inline docs (0=unlimited)
  INLINE_DOCS_LIMIT: ${{ github.event.client_payload.inline_docs_limit || github.event.inputs.inline_docs_limit || '0' }}

jobs:
  doc-pipeline:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    # Skip actual work when triggered by push (push trigger only registers workflow with GitHub)
    # This allows workflow_dispatch API calls to work on feature branches
    if: github.event_name != 'push'

    steps:
      # =========================================================================
      # SEND START NOTIFICATION
      # Notify orchestrator that workflow has started running
      # =========================================================================
      - name: Send Start Notification
        if: env.CALLBACK_URL != ''
        continue-on-error: true
        env:
          WEBHOOK_SECRET: ${{ github.event.client_payload.webhook_secret || github.event.inputs.webhook_secret || '' }}
        run: |
          if [ -n "$WEBHOOK_SECRET" ]; then
            echo "::add-mask::$WEBHOOK_SECRET"
          fi

          echo "üì§ Sending start notification to: $CALLBACK_URL"

          HTTP_CODE=$(curl -s -o /tmp/webhook_start_response.txt -w "%{http_code}" -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $WEBHOOK_SECRET" \
            -d "{
              \"run_id\": \"$RUN_ID\",
              \"repo_id\": \"$REPO_ID\",
              \"status\": \"running\",
              \"workflow_run_id\": ${{ github.run_id }},
              \"workflow_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
              \"current_stage\": \"inline-docs\"
            }") || HTTP_CODE="failed"

          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
            echo "‚úÖ Start notification sent (HTTP $HTTP_CODE)"
          else
            echo "‚ö†Ô∏è Start notification returned HTTP $HTTP_CODE (non-blocking)"
          fi

      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ env.SOURCE_BRANCH }}

      # =========================================================================
      # SETUP: Clone Dependency Repos (if configured)
      # =========================================================================
      - name: Clone Dependency Repositories
        if: env.DEPENDENCIES != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # SECURITY: Pass secret per-step with inline masking
          GITHUB_PAT: ${{ github.event.client_payload.github_pat || github.event.inputs.github_pat || '' }}
        run: |
          # SECURITY: Mask secret immediately before any echo
          if [ -n "$GITHUB_PAT" ]; then
            echo "::add-mask::$GITHUB_PAT"
          fi

          echo "üì¶ Cloning dependency repositories for documentation context..."
          echo "   Dependencies: $DEPENDENCIES"
          mkdir -p ../deps

          # Determine which token to use (PAT preferred for cross-repo access)
          if [ -n "$GITHUB_PAT" ]; then
            echo "   Using provided GitHub PAT for cross-repo access"
            CLONE_TOKEN="$GITHUB_PAT"
          else
            echo "   Using default GITHUB_TOKEN (may not work for private cross-repo)"
            CLONE_TOKEN="$GH_TOKEN"
          fi

          # Configure git to use token for private repos
          git config --global url."https://x-access-token:${CLONE_TOKEN}@github.com/".insteadOf "https://github.com/"

          IFS=',' read -ra DEPS <<< "$DEPENDENCIES"
          for dep in "${DEPS[@]}"; do
            repo_name=$(basename $dep)
            echo ""
            echo "  üìÅ Cloning: $dep ‚Üí ../deps/$repo_name"
            if git clone --depth 1 "https://github.com/$dep.git" "../deps/$repo_name" 2>&1; then
              file_count=$(find "../deps/$repo_name" -type f \( -name "*.java" -o -name "*.ts" -o -name "*.py" -o -name "*.rs" \) 2>/dev/null | wc -l | tr -d ' ')
              echo "     ‚úÖ Cloned successfully ($file_count source files)"
            else
              echo "     ‚ö†Ô∏è Failed to clone $dep"
              echo "        If private, pass github_pat with 'repo' scope"
            fi
          done

          echo ""
          echo "üìÇ Dependency directories:"
          ls -la ../deps/ 2>/dev/null || echo "   No dependencies cloned"
          echo ""
          echo "üìä Total dependency source files available for documentation:"
          find ../deps -type f \( -name "*.java" -o -name "*.ts" -o -name "*.py" -o -name "*.rs" \) 2>/dev/null | wc -l | xargs echo "  "

      # =========================================================================
      # STAGE 1: INLINE CLASS DOCUMENTATION
      # Generate .md files next to each source class
      # =========================================================================
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Stage 1 Dependencies
        if: contains(env.STAGES, 'inline-docs')
        run: npm install @anthropic-ai/sdk glob

      - name: Generate Inline Class Documentation
        id: stage1
        if: contains(env.STAGES, 'inline-docs')
        env:
          # SECURITY: Pass secret per-step with inline masking
          ANTHROPIC_API_KEY: ${{ github.event.client_payload.anthropic_api_key || github.event.inputs.anthropic_api_key || '' }}
        run: |
          # SECURITY: Mask secret immediately before any echo
          if [ -n "$ANTHROPIC_API_KEY" ]; then
            echo "::add-mask::$ANTHROPIC_API_KEY"
          fi

          echo "üìù Stage 1: Generating inline documentation..."

          cat > generate-inline-docs.js << 'SCRIPT_EOF'
          #!/usr/bin/env node
          const Anthropic = require('@anthropic-ai/sdk');
          const { glob } = require('glob');
          const fs = require('fs').promises;
          const path = require('path');

          const client = new Anthropic.default();

          // Configure source patterns based on project type
          const SOURCE_PATTERNS = [
            // === MAIN REPO ===
            // TypeScript/JavaScript
            'src/**/*.ts', 'src/**/*.tsx', 'lib/**/*.ts', 'app/**/*.ts', 'app/**/*.tsx',
            'components/**/*.ts', 'components/**/*.tsx', 'hooks/**/*.ts', 'utils/**/*.ts',
            // Java
            'src/**/*.java', '**/src/main/java/**/*.java',
            // Python
            'src/**/*.py', 'lib/**/*.py',
            // Rust - multiple common patterns for different project layouts
            'src/**/*.rs',           // Standard cargo layout (src/main.rs, src/lib.rs)
            '*.rs',                  // Root-level .rs files (less common)
            'cli/**/*.rs',           // CLI-specific modules
            'crates/**/*.rs',        // Workspace crates
            'bin/**/*.rs',           // Binary source files
            // Go - standard project layouts
            '*.go',                  // Root-level (main.go)
            'cmd/**/*.go',           // CLI commands
            'internal/**/*.go',      // Internal packages
            'pkg/**/*.go',           // Public packages
            'api/**/*.go',           // API handlers

            // === DEPENDENCY REPOS (cloned to ../deps/) ===
            // TypeScript/JavaScript
            '../deps/**/src/**/*.ts', '../deps/**/src/**/*.tsx', '../deps/**/lib/**/*.ts',
            // Java
            '../deps/**/src/main/java/**/*.java',
            // Python
            '../deps/**/src/**/*.py', '../deps/**/lib/**/*.py',
            // Rust
            '../deps/**/src/**/*.rs', '../deps/**/crates/**/*.rs',
            // Go
            '../deps/**/*.go',

            // === EXCLUSIONS ===
            '!**/*.test.*', '!**/*.spec.*', '!**/node_modules/**',
            '!**/target/**', '!**/build/**', '!**/__pycache__/**',
            '!**/dist/**', '!**/.next/**', '!**/coverage/**',
            '!**/vendor/**',         // Rust/Go vendored dependencies
            '!**/*_test.go'          // Go test files
          ];

          // Skip generating docs for files that already have .md files
          async function hasExistingDoc(filePath) {
            const docPath = filePath.replace(/\.[^.]+$/, '.md');
            try {
              await fs.access(docPath);
              return true;
            } catch {
              return false;
            }
          }

          async function generateInlineDoc(filePath) {
            const content = await fs.readFile(filePath, 'utf-8');
            const ext = path.extname(filePath);
            const fileName = path.basename(filePath, ext);
            const docPath = filePath.replace(/\.[^.]+$/, '.md');

            // Skip if content is too short (likely a simple export/index file)
            if (content.length < 100) {
              console.log(`  ‚è≠Ô∏è  Skipping ${fileName} (too short)`);
              return null;
            }

            // Determine language for code blocks
            const langMap = {
              '.ts': 'typescript', '.tsx': 'typescript',
              '.js': 'javascript', '.jsx': 'javascript',
              '.java': 'java', '.py': 'python', '.rs': 'rust',
              '.go': 'go'
            };
            const language = langMap[ext] || 'plaintext';

            const response = await client.messages.create({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 2048,
              system: `You are a technical documentation expert. Generate concise, developer-friendly documentation for source code files.

          FORMAT REQUIREMENTS:
          - Start with a brief 1-2 sentence description of the file's purpose
          - Include a "## Key Components" section listing main exports/classes/functions
          - Include a "## Usage Example" section with practical code examples
          - Keep it concise - aim for 100-300 words total
          - Use ${language} code blocks for examples
          - Do not include the file name as a heading (it will be in the filename)`,
              messages: [{
                role: 'user',
                content: `Document this ${language} file "${fileName}${ext}":\n\n\`\`\`${language}\n${content.slice(0, 12000)}\n\`\`\``
              }]
            });

            const docContent = response.content[0].text;
            await fs.writeFile(docPath, docContent);
            console.log(`  ‚úÖ Generated: ${docPath}`);
            return docPath;
          }

          async function main() {
            console.log('üîç Scanning for source files...');

            // Debug mode: limit total files (0 = unlimited)
            const FILE_LIMIT = parseInt(process.env.INLINE_DOCS_LIMIT || '0', 10);
            if (FILE_LIMIT > 0) {
              console.log(`‚ö° DEBUG MODE: Limiting to ${FILE_LIMIT} file(s) total`);
            }

            // Find all matching files
            const allFiles = await glob(SOURCE_PATTERNS, { ignore: ['**/node_modules/**'] });
            console.log(`Found ${allFiles.length} source files total`);

            // Apply limit to total files (not per folder)
            let files = allFiles;
            if (FILE_LIMIT > 0) {
              files = allFiles.slice(0, FILE_LIMIT);
              console.log(`After limit: processing ${files.length} of ${allFiles.length} files`);
            }

            let generated = 0;
            let skipped = 0;
            let errors = 0;

            for (const file of files) {
              try {
                // Skip if doc already exists
                if (await hasExistingDoc(file)) {
                  console.log(`  ‚è≠Ô∏è  Skipping ${file} (doc exists)`);
                  skipped++;
                  continue;
                }

                const result = await generateInlineDoc(file);
                if (result) generated++;
                else skipped++;

                // Rate limiting - wait 500ms between API calls
                await new Promise(r => setTimeout(r, 500));
              } catch (error) {
                console.error(`  ‚ùå Error processing ${file}:`, error.message);
                errors++;
              }
            }

            console.log(`\nüìä Stage 1 Complete:`);
            console.log(`   Generated: ${generated}`);
            console.log(`   Skipped: ${skipped}`);
            console.log(`   Errors: ${errors}`);

            // Write stats for later stages
            await fs.writeFile('.doc-stage1-stats.json', JSON.stringify({
              generated, skipped, errors, timestamp: new Date().toISOString()
            }));
          }

          main().catch(err => {
            console.error('Stage 1 failed:', err);
            process.exit(1);
          });
          SCRIPT_EOF

          node generate-inline-docs.js

          # Count generated files
          INLINE_DOCS=$(find . -name "*.md" -newer .git -type f | wc -l)
          echo "stage1_files=$INLINE_DOCS" >> $GITHUB_OUTPUT
          echo "stage1_status=completed" >> $GITHUB_OUTPUT

      - name: Report Stage 1 Progress
        if: always() && contains(env.STAGES, 'inline-docs') && env.CALLBACK_URL != ''
        continue-on-error: true
        env:
          WEBHOOK_SECRET: ${{ github.event.client_payload.webhook_secret || github.event.inputs.webhook_secret || '' }}
        run: |
          if [ -n "$WEBHOOK_SECRET" ]; then
            echo "::add-mask::$WEBHOOK_SECRET"
          fi

          echo "üì§ Reporting Stage 1 (Inline Docs) completion..."

          curl -s -o /dev/null -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $WEBHOOK_SECRET" \
            -d "{
              \"run_id\": \"$RUN_ID\",
              \"repo_id\": \"$REPO_ID\",
              \"status\": \"running\",
              \"workflow_run_id\": ${{ github.run_id }},
              \"workflow_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
              \"current_stage\": \"codewiki\",
              \"stage_results\": {
                \"inline-docs\": {
                  \"status\": \"${{ steps.stage1.outputs.stage1_status || 'skipped' }}\",
                  \"files_generated\": ${{ steps.stage1.outputs.stage1_files || 0 }}
                }
              }
            }" || echo "‚ö†Ô∏è Stage 1 progress notification failed (non-blocking)"

      # =========================================================================
      # STAGE 2: CODEWIKI ANALYSIS
      # Generate architecture overview and module tree
      # =========================================================================
      - name: Setup Python 3.12
        if: contains(env.STAGES, 'codewiki')
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install CodeWiki
        id: codewiki_install
        if: contains(env.STAGES, 'codewiki')
        continue-on-error: true
        run: |
          # Install keyrings.alt for headless keyring support in CI environments
          pip install keyrings.alt
          pip install git+https://github.com/FSoft-AI4Code/CodeWiki.git
          echo "codewiki_installed=true" >> $GITHUB_OUTPUT

      - name: Configure CodeWiki
        id: codewiki_config
        if: contains(env.STAGES, 'codewiki') && steps.codewiki_install.outputs.codewiki_installed == 'true'
        continue-on-error: true
        env:
          # SECURITY: Pass secret per-step with inline masking
          # NOTE: CodeWiki uses OpenAI provider internally, so we need OpenAI API key
          OPENAI_API_KEY: ${{ github.event.client_payload.openai_api_key || github.event.inputs.openai_api_key || '' }}
          # Set keyring backend via env var (must be set before any keyring operations)
          PYTHON_KEYRING_BACKEND: keyrings.alt.file.PlaintextKeyring
        run: |
          # SECURITY: Mask secret immediately before any echo
          if [ -n "$OPENAI_API_KEY" ]; then
            echo "::add-mask::$OPENAI_API_KEY"
          fi

          # === KEYRING CONFIGURATION FOR CI ===
          # CodeWiki stores API keys in system keyring. In CI (no GUI), we must:
          # 1. Create keyring config to specify PlaintextKeyring backend
          # 2. Create data directory for credential storage
          # See: https://github.com/FSoft-AI4Code/CodeWiki - uses keyring.set_password()

          echo "üîë Setting up keyring for headless CI environment..."

          # Create keyring configuration directory and config file
          mkdir -p ~/.config/python_keyring
          cat > ~/.config/python_keyring/keyringrc.cfg << 'KEYRING_CFG'
          [backend]
          default-keyring=keyrings.alt.file.PlaintextKeyring
          KEYRING_CFG

          # Ensure keyring data directory exists with proper permissions
          mkdir -p ~/.local/share/python_keyring
          chmod 700 ~/.local/share/python_keyring

          # Debug: Verify keyring is properly configured
          echo "üìã Keyring backend verification:"
          python3 -c "import keyring; print(f'  Active backend: {keyring.get_keyring()}')"

          # CodeWiki uses pydantic-ai's OpenAIProvider internally (NOT Anthropic provider)
          # Despite docs showing Anthropic, the codebase only works with OpenAI-compatible APIs
          # See: https://github.com/FSoft-AI4Code/CodeWiki/blob/main/codewiki/src/be/llm_services.py
          # Using gpt-5.2 (Dec 2025) - Thinking variant, best for coding/planning
          codewiki config set \
            --api-key "$OPENAI_API_KEY" \
            --base-url "https://api.openai.com/v1" \
            --main-model "gpt-5.2" \
            --cluster-model "gpt-5.2"

          # Debug: Verify config was saved
          echo "üìã CodeWiki config verification:"
          codewiki config show || echo "  (config show failed)"

          echo "codewiki_configured=true" >> $GITHUB_OUTPUT

      - name: Run CodeWiki Analysis
        id: stage2
        if: contains(env.STAGES, 'codewiki') && steps.codewiki_config.outputs.codewiki_configured == 'true'
        continue-on-error: true
        env:
          # Keyring backend for CI (must match config step)
          PYTHON_KEYRING_BACKEND: keyrings.alt.file.PlaintextKeyring
          # Fallback: CodeWiki's internal LLM service can read from these env vars
          # See: codewiki/src/config.py - LLM_API_KEY = os.getenv('LLM_API_KEY', ...)
          LLM_API_KEY: ${{ github.event.client_payload.openai_api_key || github.event.inputs.openai_api_key || '' }}
          LLM_BASE_URL: https://api.openai.com/v1
          OPENAI_API_KEY: ${{ github.event.client_payload.openai_api_key || github.event.inputs.openai_api_key || '' }}
        run: |
          # SECURITY: Mask secrets immediately
          if [ -n "$LLM_API_KEY" ]; then
            echo "::add-mask::$LLM_API_KEY"
          fi
          if [ -n "$OPENAI_API_KEY" ]; then
            echo "::add-mask::$OPENAI_API_KEY"
          fi

          echo "üìä Stage 2: Running CodeWiki analysis..."

          # Debug: Show active keyring backend
          echo "üìã Keyring verification before generate:"
          python3 -c "import keyring; print(f'  Active backend: {keyring.get_keyring()}')"

          mkdir -p docs/codewiki

          # Run CodeWiki with verbose output
          codewiki generate --output ./docs/codewiki --verbose || {
            echo "‚ö†Ô∏è CodeWiki failed, creating placeholder docs"
            echo "# CodeWiki Documentation" > docs/codewiki/overview.md
            echo "" >> docs/codewiki/overview.md
            echo "CodeWiki analysis was skipped or failed. Run manually with:" >> docs/codewiki/overview.md
            echo "\`\`\`bash" >> docs/codewiki/overview.md
            echo "pip install git+https://github.com/FSoft-AI4Code/CodeWiki.git" >> docs/codewiki/overview.md
            echo "codewiki generate --output ./docs/codewiki" >> docs/codewiki/overview.md
            echo "\`\`\`" >> docs/codewiki/overview.md
          }

          CODEWIKI_FILES=$(find docs/codewiki -name "*.md" -type f 2>/dev/null | wc -l)
          echo "stage2_files=$CODEWIKI_FILES" >> $GITHUB_OUTPUT
          echo "stage2_status=completed" >> $GITHUB_OUTPUT

      - name: Report Stage 2 Progress
        if: always() && contains(env.STAGES, 'codewiki') && env.CALLBACK_URL != ''
        continue-on-error: true
        env:
          WEBHOOK_SECRET: ${{ github.event.client_payload.webhook_secret || github.event.inputs.webhook_secret || '' }}
        run: |
          if [ -n "$WEBHOOK_SECRET" ]; then
            echo "::add-mask::$WEBHOOK_SECRET"
          fi

          echo "üì§ Reporting Stage 2 (CodeWiki) completion..."

          curl -s -o /dev/null -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $WEBHOOK_SECRET" \
            -d "{
              \"run_id\": \"$RUN_ID\",
              \"repo_id\": \"$REPO_ID\",
              \"status\": \"running\",
              \"workflow_run_id\": ${{ github.run_id }},
              \"workflow_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
              \"current_stage\": \"voltagent\",
              \"stage_results\": {
                \"inline-docs\": {
                  \"status\": \"${{ steps.stage1.outputs.stage1_status || 'skipped' }}\",
                  \"files_generated\": ${{ steps.stage1.outputs.stage1_files || 0 }}
                },
                \"codewiki\": {
                  \"status\": \"${{ steps.stage2.outputs.stage2_status || 'skipped' }}\",
                  \"files_generated\": ${{ steps.stage2.outputs.stage2_files || 0 }}
                }
              }
            }" || echo "‚ö†Ô∏è Stage 2 progress notification failed (non-blocking)"

      # =========================================================================
      # STAGE 3: VOLTAGENT TUTORIALS
      # Generate getting started guides and how-to tutorials
      # =========================================================================
      - name: Install VoltAgent Dependencies
        if: contains(env.STAGES, 'voltagent')
        run: |
          npm install @anthropic-ai/sdk glob

      - name: Generate Tutorials with AI
        id: stage3
        if: contains(env.STAGES, 'voltagent')
        env:
          # SECURITY: Pass secret per-step with inline masking
          ANTHROPIC_API_KEY: ${{ github.event.client_payload.anthropic_api_key || github.event.inputs.anthropic_api_key || '' }}
        run: |
          # SECURITY: Mask secret immediately before any echo
          if [ -n "$ANTHROPIC_API_KEY" ]; then
            echo "::add-mask::$ANTHROPIC_API_KEY"
          fi

          echo "üìö Stage 3: Generating tutorials..."

          cat > generate-tutorials.js << 'SCRIPT_EOF'
          #!/usr/bin/env node
          const Anthropic = require('@anthropic-ai/sdk');
          const fs = require('fs').promises;
          const path = require('path');
          const { glob } = require('glob');

          const client = new Anthropic.default();

          async function gatherContext() {
            const context = { readme: '', claudeMd: '', inlineDocs: [], codewiki: [] };

            // Read README
            try {
              context.readme = await fs.readFile('README.md', 'utf-8');
            } catch {}

            // Read CLAUDE.md
            try {
              context.claudeMd = await fs.readFile('CLAUDE.md', 'utf-8');
            } catch {}

            // Gather inline docs from Stage 1
            const inlineMdFiles = await glob('src/**/*.md');
            for (const file of inlineMdFiles.slice(0, 20)) {
              try {
                const content = await fs.readFile(file, 'utf-8');
                context.inlineDocs.push({ path: file, content: content.slice(0, 1000) });
              } catch {}
            }

            // Gather CodeWiki docs from Stage 2
            const codewikiFiles = await glob('docs/codewiki/**/*.md');
            for (const file of codewikiFiles.slice(0, 10)) {
              try {
                const content = await fs.readFile(file, 'utf-8');
                context.codewiki.push({ path: file, content: content.slice(0, 2000) });
              } catch {}
            }

            return context;
          }

          async function generateTutorial(title, prompt, context, outputPath) {
            console.log(`  üìù Generating: ${title}...`);

            const contextSummary = `
          PROJECT CONTEXT:
          ${context.readme.slice(0, 3000)}

          ${context.claudeMd ? `PROJECT INSTRUCTIONS (CLAUDE.md):\n${context.claudeMd.slice(0, 2000)}` : ''}

          INLINE DOCUMENTATION (${context.inlineDocs.length} files):
          ${context.inlineDocs.map(d => `- ${d.path}`).join('\n')}

          CODEWIKI DOCUMENTATION (${context.codewiki.length} files):
          ${context.codewiki.map(d => `- ${d.path}`).join('\n')}
          `;

            const response = await client.messages.create({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 4096,
              system: `You are a technical writer creating developer documentation.
          Write clear, practical documentation that developers can follow step-by-step.
          Use Markdown formatting with proper headings, code blocks, and examples.
          Be concise but thorough. Include real code examples when helpful.`,
              messages: [{
                role: 'user',
                content: `${prompt}\n\n${contextSummary}`
              }]
            });

            const content = response.content[0].text;
            await fs.mkdir(path.dirname(outputPath), { recursive: true });
            await fs.writeFile(outputPath, content);
            console.log(`  ‚úÖ Written: ${outputPath}`);
            return outputPath;
          }

          async function main() {
            console.log('üîç Gathering project context...');
            const context = await gatherContext();

            console.log(`  README: ${context.readme.length} chars`);
            console.log(`  CLAUDE.md: ${context.claudeMd.length} chars`);
            console.log(`  Inline docs: ${context.inlineDocs.length} files`);
            console.log(`  CodeWiki docs: ${context.codewiki.length} files`);

            const tutorials = [
              {
                title: 'Getting Started',
                outputPath: 'docs/tutorials/getting-started.md',
                prompt: `Write a "Getting Started" guide for this project.
          Include:
          1. Prerequisites (what needs to be installed)
          2. Installation steps
          3. Basic configuration
          4. Running the project locally
          5. First steps / "Hello World" equivalent
          6. Common issues and solutions

          Make it beginner-friendly but assume the reader knows basic programming.`
              },
              {
                title: 'Architecture Overview',
                outputPath: 'docs/tutorials/architecture-overview.md',
                prompt: `Write an "Architecture Overview" document for this project.
          Include:
          1. High-level architecture diagram description (describe what a diagram would show)
          2. Main components and their responsibilities
          3. Data flow between components
          4. Key design decisions and patterns used
          5. Directory/folder structure explanation

          Focus on helping new developers understand the codebase structure.`
              },
              {
                title: 'API Examples',
                outputPath: 'docs/tutorials/api-examples.md',
                prompt: `Write an "API Usage Examples" guide for this project.
          Include:
          1. Main API endpoints or functions available
          2. Authentication (if applicable)
          3. Common use cases with code examples
          4. Error handling patterns
          5. Best practices

          Include practical, copy-paste ready code examples.`
              }
            ];

            let generated = 0;
            for (const tutorial of tutorials) {
              try {
                await generateTutorial(
                  tutorial.title,
                  tutorial.prompt,
                  context,
                  tutorial.outputPath
                );
                generated++;
                // Rate limiting
                await new Promise(r => setTimeout(r, 1000));
              } catch (error) {
                console.error(`  ‚ùå Failed: ${tutorial.title}:`, error.message);
              }
            }

            console.log(`\nüìä Stage 3 Complete:`);
            console.log(`   Generated: ${generated} tutorials`);

            await fs.writeFile('.doc-stage3-stats.json', JSON.stringify({
              generated, timestamp: new Date().toISOString()
            }));
          }

          main().catch(err => {
            console.error('Stage 3 failed:', err);
            process.exit(1);
          });
          SCRIPT_EOF

          node generate-tutorials.js

          TUTORIAL_FILES=$(find docs/tutorials -name "*.md" -type f 2>/dev/null | wc -l)
          echo "stage3_files=$TUTORIAL_FILES" >> $GITHUB_OUTPUT
          echo "stage3_status=completed" >> $GITHUB_OUTPUT

      - name: Report Stage 3 Progress
        if: always() && contains(env.STAGES, 'voltagent') && env.CALLBACK_URL != ''
        continue-on-error: true
        env:
          WEBHOOK_SECRET: ${{ github.event.client_payload.webhook_secret || github.event.inputs.webhook_secret || '' }}
        run: |
          if [ -n "$WEBHOOK_SECRET" ]; then
            echo "::add-mask::$WEBHOOK_SECRET"
          fi

          echo "üì§ Reporting Stage 3 (VoltAgent) completion..."

          curl -s -o /dev/null -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $WEBHOOK_SECRET" \
            -d "{
              \"run_id\": \"$RUN_ID\",
              \"repo_id\": \"$REPO_ID\",
              \"status\": \"running\",
              \"workflow_run_id\": ${{ github.run_id }},
              \"workflow_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
              \"current_stage\": \"creating-pr\",
              \"stage_results\": {
                \"inline-docs\": {
                  \"status\": \"${{ steps.stage1.outputs.stage1_status || 'skipped' }}\",
                  \"files_generated\": ${{ steps.stage1.outputs.stage1_files || 0 }}
                },
                \"codewiki\": {
                  \"status\": \"${{ steps.stage2.outputs.stage2_status || 'skipped' }}\",
                  \"files_generated\": ${{ steps.stage2.outputs.stage2_files || 0 }}
                },
                \"voltagent\": {
                  \"status\": \"${{ steps.stage3.outputs.stage3_status || 'skipped' }}\",
                  \"files_generated\": ${{ steps.stage3.outputs.stage3_files || 0 }}
                }
              }
            }" || echo "‚ö†Ô∏è Stage 3 progress notification failed (non-blocking)"

      # =========================================================================
      # CREATE PULL REQUEST
      # =========================================================================
      - name: Cleanup Temporary Files
        run: |
          echo "üßπ Cleaning up temporary files before PR creation..."

          # Remove generated scripts (created with heredoc)
          rm -f generate-inline-docs.js
          rm -f generate-tutorials.js

          # Remove stats files
          rm -f .doc-stage1-stats.json
          rm -f .doc-stage3-stats.json

          # Remove npm artifacts (installed for scripts)
          rm -rf node_modules
          rm -f package.json
          rm -f package-lock.json

          echo "‚úÖ Cleanup complete"

      - name: Sanitize Branch Name
        id: branch-name
        run: |
          # Replace colons and other invalid chars with hyphens for git branch name
          SAFE_RUN_ID=$(echo "$RUN_ID" | sed 's/[:]/-/g' | sed 's/[^a-zA-Z0-9._-]/-/g')
          echo "safe_run_id=$SAFE_RUN_ID" >> $GITHUB_OUTPUT
          echo "üìù Sanitized RUN_ID for branch: $SAFE_RUN_ID"

      - name: Stage Generated Documentation
        id: stage-docs
        run: |
          echo "üìÅ Staging generated documentation files..."

          # Count files before staging
          BEFORE_COUNT=$(git status --porcelain | wc -l)
          echo "   Files to stage: $BEFORE_COUNT"

          # Stage all generated .md files (documentation)
          git add -f docs/**/*.md 2>/dev/null || true
          git add -f src/**/*.md 2>/dev/null || true
          git add -f lib/**/*.md 2>/dev/null || true
          git add -f app/**/*.md 2>/dev/null || true
          git add -f components/**/*.md 2>/dev/null || true
          git add -f hooks/**/*.md 2>/dev/null || true
          git add -f utils/**/*.md 2>/dev/null || true
          git add -f crates/**/*.md 2>/dev/null || true
          git add -f cli/**/*.md 2>/dev/null || true
          git add -f bin/**/*.md 2>/dev/null || true
          git add -f cmd/**/*.md 2>/dev/null || true
          git add -f internal/**/*.md 2>/dev/null || true
          git add -f pkg/**/*.md 2>/dev/null || true
          git add -f api/**/*.md 2>/dev/null || true

          # Stage root-level .md files (except README.md to avoid conflicts)
          for f in *.md; do
            if [ -f "$f" ] && [ "$f" != "README.md" ] && [ "$f" != "CHANGELOG.md" ]; then
              git add -f "$f" 2>/dev/null || true
            fi
          done

          # Count staged files
          STAGED_COUNT=$(git diff --cached --name-only | wc -l)
          echo "   Staged files: $STAGED_COUNT"
          echo "staged_count=$STAGED_COUNT" >> $GITHUB_OUTPUT

          # Show what was staged
          echo ""
          echo "üìã Staged files:"
          git diff --cached --name-only | head -50

          if [ "$STAGED_COUNT" -eq "0" ]; then
            echo ""
            echo "‚ö†Ô∏è No documentation files to stage"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Create Pull Request
        if: steps.stage-docs.outputs.has_changes == 'true'
        id: create-pr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            docs: Automated documentation update [skip ci]

            Generated by Doc Orchestrator Pipeline
            Run ID: ${{ env.RUN_ID }}
          title: "üìö Automated Documentation Update"
          body: |
            ## Documentation Pipeline Results

            **Run ID:** `${{ env.RUN_ID }}`

            ### Stage 1: Inline Documentation
            - Status: ${{ steps.stage1.outputs.stage1_status || 'skipped' }}
            - Files generated: ${{ steps.stage1.outputs.stage1_files || '0' }}
            - Generated `.md` files next to source classes explaining their purpose

            ### Stage 2: CodeWiki Analysis
            - Status: ${{ steps.stage2.outputs.stage2_status || 'skipped' }}
            - Files generated: ${{ steps.stage2.outputs.stage2_files || '0' }}
            - Architecture overview and module documentation

            ### Stage 3: VoltAgent Tutorials
            - Status: ${{ steps.stage3.outputs.stage3_status || 'skipped' }}
            - Files generated: ${{ steps.stage3.outputs.stage3_files || '0' }}
            - Getting started guides and how-to tutorials

            ---

            **Review checklist:**
            - [ ] Check generated inline docs for accuracy
            - [ ] Review architecture documentation
            - [ ] Test code examples in tutorials

            ---
            ü§ñ Generated by [Doc Orchestrator](https://github.com/openframe-oss-tenant)
          branch: docs/orchestrator-${{ steps.branch-name.outputs.safe_run_id }}
          base: ${{ github.event.repository.default_branch }}
          delete-branch: true
          labels: |
            documentation
            automated
          # Only include documentation files in the PR - excludes temp scripts, node_modules, etc.
          add-paths: |
            docs/**
            src/**/*.md
            lib/**/*.md
            app/**/*.md
            components/**/*.md
            hooks/**/*.md
            utils/**/*.md
            crates/**/*.md
            cli/**/*.md
            bin/**/*.md
            cmd/**/*.md
            internal/**/*.md
            pkg/**/*.md
            api/**/*.md
            *.md

      # =========================================================================
      # SEND WEBHOOK NOTIFICATION
      # =========================================================================
      - name: Send Webhook Notification
        if: always() && env.CALLBACK_URL != ''
        continue-on-error: true  # Don't fail the workflow if callback fails
        env:
          # SECURITY: Pass secret per-step with inline masking
          WEBHOOK_SECRET: ${{ github.event.client_payload.webhook_secret || github.event.inputs.webhook_secret || '' }}
        run: |
          # SECURITY: Mask secret immediately before any echo
          if [ -n "$WEBHOOK_SECRET" ]; then
            echo "::add-mask::$WEBHOOK_SECRET"
          fi

          echo "üì§ Sending webhook to: $CALLBACK_URL"

          # Determine overall status
          if [ "${{ steps.stage-docs.outputs.has_changes }}" != "true" ]; then
            STATUS="no_changes"
            echo "   Status: no_changes (no documentation files generated)"
          elif [ "${{ job.status }}" = "success" ]; then
            STATUS="success"
          else
            STATUS="failure"
          fi

          # Build stage results JSON
          STAGE_RESULTS=$(cat << EOF
          {
            "inline_docs": {
              "status": "${{ steps.stage1.outputs.stage1_status || 'skipped' }}",
              "files_generated": ${{ steps.stage1.outputs.stage1_files || 0 }}
            },
            "codewiki": {
              "status": "${{ steps.stage2.outputs.stage2_status || 'skipped' }}",
              "files_generated": ${{ steps.stage2.outputs.stage2_files || 0 }}
            },
            "voltagent": {
              "status": "${{ steps.stage3.outputs.stage3_status || 'skipped' }}",
              "files_generated": ${{ steps.stage3.outputs.stage3_files || 0 }}
            }
          }
          EOF
          )

          # Get sanitized branch name
          SAFE_BRANCH="docs/orchestrator-${{ steps.branch-name.outputs.safe_run_id }}"

          # Send webhook (don't fail if it doesn't work)
          HTTP_CODE=$(curl -s -o /tmp/webhook_response.txt -w "%{http_code}" -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $WEBHOOK_SECRET" \
            -d "{
              \"run_id\": \"$RUN_ID\",
              \"repo_id\": \"$REPO_ID\",
              \"status\": \"$STATUS\",
              \"workflow_run_id\": ${{ github.run_id }},
              \"workflow_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
              \"pr_url\": \"${{ steps.create-pr.outputs.pull-request-url }}\",
              \"pr_number\": ${{ steps.create-pr.outputs.pull-request-number || 'null' }},
              \"branch\": \"$SAFE_BRANCH\",
              \"stage_results\": $STAGE_RESULTS
            }") || HTTP_CODE="failed"

          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
            echo "‚úÖ Webhook sent successfully (HTTP $HTTP_CODE)"
          else
            echo "‚ö†Ô∏è Webhook notification returned HTTP $HTTP_CODE (non-blocking)"
            cat /tmp/webhook_response.txt 2>/dev/null || true
          fi

      - name: Pipeline Summary
        if: always()
        run: |
          echo "## üìö Doc Orchestrator Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status | Files |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Inline Docs | ${{ steps.stage1.outputs.stage1_status || 'skipped' }} | ${{ steps.stage1.outputs.stage1_files || '0' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| CodeWiki | ${{ steps.stage2.outputs.stage2_status || 'skipped' }} | ${{ steps.stage2.outputs.stage2_files || '0' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tutorials | ${{ steps.stage3.outputs.stage3_status || 'skipped' }} | ${{ steps.stage3.outputs.stage3_files || '0' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ steps.create-pr.outputs.pull-request-url }}" ]; then
            echo "**Pull Request:** ${{ steps.create-pr.outputs.pull-request-url }}" >> $GITHUB_STEP_SUMMARY
          fi
