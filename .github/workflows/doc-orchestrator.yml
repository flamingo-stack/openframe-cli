# Doc Orchestrator Pipeline
# ===========================
# This GitHub Actions workflow is triggered by the multi-platform-hub to generate
# comprehensive documentation for this repository and create a PR with the results.
#
# 3-Stage Pipeline:
# 1. Inline Documentation - Generate .md files next to source classes
# 2. CodeWiki Analysis - Architecture overview and Mermaid diagrams
# 3. VoltAgent Tutorials - AI-generated getting started and how-to guides
#
# Installation:
# Copy this file to .github/workflows/doc-orchestrator.yml in your target repository.
# No secrets required - all credentials are securely passed from the orchestrator at runtime.

name: Doc Orchestrator Pipeline

on:
  # Push trigger - registers workflow with GitHub Actions (required for workflow_dispatch API)
  # Only triggers when the workflow file itself is modified (runs once on initial setup)
  push:
    paths:
      - '.github/workflows/doc-orchestrator.yml'

  repository_dispatch:
    types: [doc-orchestrator]

  workflow_dispatch:
    inputs:
      run_id:
        description: 'Run ID for tracking'
        required: false
        default: 'manual'
      repo_id:
        description: 'Repository ID in orchestrator database'
        required: false
        default: ''
      callback_url:
        description: 'Webhook URL for completion callback'
        required: false
        default: ''
      stages:
        description: 'Comma-separated stages to run (inline-docs,codewiki,voltagent)'
        required: false
        default: 'inline-docs,codewiki,voltagent'
      dependencies:
        description: 'Comma-separated dependency repos'
        required: false
        default: ''
      source_branch:
        description: 'Branch to analyze code from (defaults to main)'
        required: false
        default: 'main'
      anthropic_api_key:
        description: 'Anthropic API key for AI processing (Stage 1 & 3)'
        required: false
        default: ''
      openai_api_key:
        description: 'OpenAI API key for CodeWiki (Stage 2) - CodeWiki only supports OpenAI provider'
        required: false
        default: ''
      webhook_secret:
        description: 'Secret for webhook authentication'
        required: false
        default: ''
      github_pat:
        description: 'GitHub PAT for cross-repo access (optional, for private dependencies)'
        required: false
        default: ''
      inline_docs_limit:
        description: 'Max files per folder for inline docs (0=unlimited, useful for testing)'
        required: false
        default: '0'
      codewiki_provider:
        description: 'LLM provider for CodeWiki (openai or anthropic)'
        required: false
        default: 'openai'
      codewiki_model:
        description: 'Model name for CodeWiki (e.g., gpt-4.1, claude-sonnet-4-0)'
        required: false
        default: 'gpt-4.1'

permissions:
  contents: write
  pull-requests: write

env:
  # SECURITY: Only NON-SENSITIVE variables in job-level env
  # Secrets are passed per-step to avoid exposure in job setup logs
  # Run configuration (non-sensitive)
  RUN_ID: ${{ github.event.client_payload.run_id || github.event.inputs.run_id || github.run_id }}
  REPO_ID: ${{ github.event.client_payload.repo_id || github.event.inputs.repo_id || '' }}
  CALLBACK_URL: ${{ github.event.client_payload.callback_url || github.event.inputs.callback_url || '' }}
  STAGES: ${{ github.event.client_payload.stages || github.event.inputs.stages || 'inline-docs,codewiki,voltagent' }}
  DEPENDENCIES: ${{ github.event.client_payload.dependencies || github.event.inputs.dependencies || '' }}
  # Branch to checkout for code analysis (github_branch from repo config)
  SOURCE_BRANCH: ${{ github.event.client_payload.source_branch || github.event.inputs.source_branch || 'main' }}
  # Debug/testing: limit files per folder for inline docs (0=unlimited)
  INLINE_DOCS_LIMIT: ${{ github.event.client_payload.inline_docs_limit || github.event.inputs.inline_docs_limit || '0' }}
  # CodeWiki LLM provider and model configuration
  CODEWIKI_PROVIDER: ${{ github.event.client_payload.codewiki_provider || github.event.inputs.codewiki_provider || 'openai' }}
  CODEWIKI_MODEL: ${{ github.event.client_payload.codewiki_model || github.event.inputs.codewiki_model || 'gpt-4.1' }}

jobs:
  doc-pipeline:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    # Skip actual work when triggered by push (push trigger only registers workflow with GitHub)
    # This allows workflow_dispatch API calls to work on feature branches
    if: github.event_name != 'push'

    steps:
      # =========================================================================
      # SEND START NOTIFICATION
      # Notify orchestrator that workflow has started running
      # =========================================================================
      - name: Send Start Notification
        if: env.CALLBACK_URL != ''
        continue-on-error: true
        env:
          WEBHOOK_SECRET: ${{ github.event.client_payload.webhook_secret || github.event.inputs.webhook_secret || '' }}
        run: |
          if [ -n "$WEBHOOK_SECRET" ]; then
            echo "::add-mask::$WEBHOOK_SECRET"
          fi

          echo "üì§ Sending start notification to: $CALLBACK_URL"

          HTTP_CODE=$(curl -s -o /tmp/webhook_start_response.txt -w "%{http_code}" -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $WEBHOOK_SECRET" \
            -d "{
              \"run_id\": \"$RUN_ID\",
              \"repo_id\": \"$REPO_ID\",
              \"status\": \"running\",
              \"workflow_run_id\": ${{ github.run_id }},
              \"workflow_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
              \"current_stage\": \"inline-docs\"
            }") || HTTP_CODE="failed"

          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
            echo "‚úÖ Start notification sent (HTTP $HTTP_CODE)"
          else
            echo "‚ö†Ô∏è Start notification returned HTTP $HTTP_CODE (non-blocking)"
          fi

      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ env.SOURCE_BRANCH }}

      # =========================================================================
      # SETUP: Clone Dependency Repos (if configured)
      # =========================================================================
      - name: Clone Dependency Repositories
        if: env.DEPENDENCIES != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # SECURITY: Pass secret per-step with inline masking
          GITHUB_PAT: ${{ github.event.client_payload.github_pat || github.event.inputs.github_pat || '' }}
        run: |
          # SECURITY: Mask secret immediately before any echo
          if [ -n "$GITHUB_PAT" ]; then
            echo "::add-mask::$GITHUB_PAT"
          fi

          echo "üì¶ Cloning dependency repositories for documentation context..."
          echo "   Dependencies: $DEPENDENCIES"
          mkdir -p ../deps

          # Determine which token to use (PAT preferred for cross-repo access)
          if [ -n "$GITHUB_PAT" ]; then
            echo "   Using provided GitHub PAT for cross-repo access"
            CLONE_TOKEN="$GITHUB_PAT"
          else
            echo "   Using default GITHUB_TOKEN (may not work for private cross-repo)"
            CLONE_TOKEN="$GH_TOKEN"
          fi

          # Configure git to use token for private repos
          git config --global url."https://x-access-token:${CLONE_TOKEN}@github.com/".insteadOf "https://github.com/"

          IFS=',' read -ra DEPS <<< "$DEPENDENCIES"
          for dep in "${DEPS[@]}"; do
            repo_name=$(basename $dep)
            echo ""
            echo "  üìÅ Cloning: $dep ‚Üí ../deps/$repo_name"
            if git clone --depth 1 "https://github.com/$dep.git" "../deps/$repo_name" 2>&1; then
              file_count=$(find "../deps/$repo_name" -type f \( -name "*.java" -o -name "*.ts" -o -name "*.py" -o -name "*.rs" \) 2>/dev/null | wc -l | tr -d ' ')
              echo "     ‚úÖ Cloned successfully ($file_count source files)"
            else
              echo "     ‚ö†Ô∏è Failed to clone $dep"
              echo "        If private, pass github_pat with 'repo' scope"
            fi
          done

          echo ""
          echo "üìÇ Dependency directories:"
          ls -la ../deps/ 2>/dev/null || echo "   No dependencies cloned"
          echo ""
          echo "üìä Total dependency source files available for documentation:"
          find ../deps -type f \( -name "*.java" -o -name "*.ts" -o -name "*.py" -o -name "*.rs" \) 2>/dev/null | wc -l | xargs echo "  "

      # =========================================================================
      # STAGE 1: INLINE CLASS DOCUMENTATION
      # Generate .md files next to each source class
      # =========================================================================
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Stage 1 Dependencies
        if: contains(env.STAGES, 'inline-docs')
        run: npm install @anthropic-ai/sdk glob

      - name: Generate Inline Class Documentation
        id: stage1
        if: contains(env.STAGES, 'inline-docs')
        env:
          # SECURITY: Pass secret per-step with inline masking
          ANTHROPIC_API_KEY: ${{ github.event.client_payload.anthropic_api_key || github.event.inputs.anthropic_api_key || '' }}
        run: |
          # SECURITY: Mask secret immediately before any echo
          if [ -n "$ANTHROPIC_API_KEY" ]; then
            echo "::add-mask::$ANTHROPIC_API_KEY"
          fi

          echo "üìù Stage 1: Generating inline documentation..."

          cat > generate-inline-docs.js << 'SCRIPT_EOF'
          #!/usr/bin/env node
          const Anthropic = require('@anthropic-ai/sdk');
          const { glob } = require('glob');
          const fs = require('fs').promises;
          const path = require('path');

          const client = new Anthropic.default();

          // Configure source patterns based on project type
          const SOURCE_PATTERNS = [
            // === MAIN REPO ===
            // TypeScript/JavaScript
            'src/**/*.ts', 'src/**/*.tsx', 'lib/**/*.ts', 'app/**/*.ts', 'app/**/*.tsx',
            'components/**/*.ts', 'components/**/*.tsx', 'hooks/**/*.ts', 'utils/**/*.ts',
            // Java
            'src/**/*.java', '**/src/main/java/**/*.java',
            // Python
            'src/**/*.py', 'lib/**/*.py',
            // Rust - multiple common patterns for different project layouts
            'src/**/*.rs',           // Standard cargo layout (src/main.rs, src/lib.rs)
            '*.rs',                  // Root-level .rs files (less common)
            'cli/**/*.rs',           // CLI-specific modules
            'crates/**/*.rs',        // Workspace crates
            'bin/**/*.rs',           // Binary source files
            // Go - standard project layouts
            '*.go',                  // Root-level (main.go)
            'cmd/**/*.go',           // CLI commands
            'internal/**/*.go',      // Internal packages
            'pkg/**/*.go',           // Public packages
            'api/**/*.go',           // API handlers

            // === DEPENDENCY REPOS (cloned to ../deps/) ===
            // TypeScript/JavaScript
            '../deps/**/src/**/*.ts', '../deps/**/src/**/*.tsx', '../deps/**/lib/**/*.ts',
            // Java
            '../deps/**/src/main/java/**/*.java',
            // Python
            '../deps/**/src/**/*.py', '../deps/**/lib/**/*.py',
            // Rust
            '../deps/**/src/**/*.rs', '../deps/**/crates/**/*.rs',
            // Go
            '../deps/**/*.go',

            // === EXCLUSIONS ===
            '!**/*.test.*', '!**/*.spec.*', '!**/node_modules/**',
            '!**/target/**', '!**/build/**', '!**/__pycache__/**',
            '!**/dist/**', '!**/.next/**', '!**/coverage/**',
            '!**/vendor/**',         // Rust/Go vendored dependencies
            '!**/*_test.go'          // Go test files
          ];

          // Skip generating docs for files that already have .md files
          async function hasExistingDoc(filePath) {
            const docPath = filePath.replace(/\.[^.]+$/, '.md');
            try {
              await fs.access(docPath);
              return true;
            } catch {
              return false;
            }
          }

          async function generateInlineDoc(filePath) {
            const content = await fs.readFile(filePath, 'utf-8');
            const ext = path.extname(filePath);
            const fileName = path.basename(filePath, ext);
            const docPath = filePath.replace(/\.[^.]+$/, '.md');

            // Skip if content is too short (likely a simple export/index file)
            if (content.length < 100) {
              console.log(`  ‚è≠Ô∏è  Skipping ${fileName} (too short)`);
              return null;
            }

            // Determine language for code blocks
            const langMap = {
              '.ts': 'typescript', '.tsx': 'typescript',
              '.js': 'javascript', '.jsx': 'javascript',
              '.java': 'java', '.py': 'python', '.rs': 'rust',
              '.go': 'go'
            };
            const language = langMap[ext] || 'plaintext';

            const response = await client.messages.create({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 2048,
              system: `You are a technical documentation expert. Generate concise, developer-friendly documentation for source code files.

          FORMAT REQUIREMENTS:
          - Start with a brief 1-2 sentence description of the file's purpose
          - Include a "## Key Components" section listing main exports/classes/functions
          - Include a "## Usage Example" section with practical code examples
          - Keep it concise - aim for 100-300 words total
          - Use ${language} code blocks for examples
          - Do not include the file name as a heading (it will be in the filename)`,
              messages: [{
                role: 'user',
                content: `Document this ${language} file "${fileName}${ext}":\n\n\`\`\`${language}\n${content.slice(0, 12000)}\n\`\`\``
              }]
            });

            const docContent = response.content[0].text;
            await fs.writeFile(docPath, docContent);
            console.log(`  ‚úÖ Generated: ${docPath}`);
            return docPath;
          }

          async function main() {
            console.log('üîç Scanning for source files...');

            // Debug mode: limit total files (0 = unlimited)
            const FILE_LIMIT = parseInt(process.env.INLINE_DOCS_LIMIT || '0', 10);
            if (FILE_LIMIT > 0) {
              console.log(`‚ö° DEBUG MODE: Limiting to ${FILE_LIMIT} file(s) total`);
            }

            // Find all matching files
            const allFiles = await glob(SOURCE_PATTERNS, { ignore: ['**/node_modules/**'] });
            console.log(`Found ${allFiles.length} source files total`);

            // Apply limit to total files (not per folder)
            let files = allFiles;
            if (FILE_LIMIT > 0) {
              files = allFiles.slice(0, FILE_LIMIT);
              console.log(`After limit: processing ${files.length} of ${allFiles.length} files`);
            }

            let generated = 0;
            let skipped = 0;
            let errors = 0;

            for (const file of files) {
              try {
                // Skip if doc already exists
                if (await hasExistingDoc(file)) {
                  console.log(`  ‚è≠Ô∏è  Skipping ${file} (doc exists)`);
                  skipped++;
                  continue;
                }

                const result = await generateInlineDoc(file);
                if (result) generated++;
                else skipped++;

                // Rate limiting - wait 500ms between API calls
                await new Promise(r => setTimeout(r, 500));
              } catch (error) {
                console.error(`  ‚ùå Error processing ${file}:`, error.message);
                errors++;
              }
            }

            console.log(`\nüìä Stage 1 Complete:`);
            console.log(`   Generated: ${generated}`);
            console.log(`   Skipped: ${skipped}`);
            console.log(`   Errors: ${errors}`);

            // Write stats for later stages
            await fs.writeFile('.doc-stage1-stats.json', JSON.stringify({
              generated, skipped, errors, timestamp: new Date().toISOString()
            }));
          }

          main().catch(err => {
            console.error('Stage 1 failed:', err);
            process.exit(1);
          });
          SCRIPT_EOF

          node generate-inline-docs.js

          # Count generated files
          INLINE_DOCS=$(find . -name "*.md" -newer .git -type f | wc -l)
          echo "stage1_files=$INLINE_DOCS" >> $GITHUB_OUTPUT
          echo "stage1_status=completed" >> $GITHUB_OUTPUT

      - name: Report Stage 1 Progress
        if: always() && contains(env.STAGES, 'inline-docs') && env.CALLBACK_URL != ''
        continue-on-error: true
        env:
          WEBHOOK_SECRET: ${{ github.event.client_payload.webhook_secret || github.event.inputs.webhook_secret || '' }}
        run: |
          if [ -n "$WEBHOOK_SECRET" ]; then
            echo "::add-mask::$WEBHOOK_SECRET"
          fi

          echo "üì§ Reporting Stage 1 (Inline Docs) completion..."

          curl -s -o /dev/null -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $WEBHOOK_SECRET" \
            -d "{
              \"run_id\": \"$RUN_ID\",
              \"repo_id\": \"$REPO_ID\",
              \"status\": \"running\",
              \"workflow_run_id\": ${{ github.run_id }},
              \"workflow_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
              \"current_stage\": \"codewiki\",
              \"stage_results\": {
                \"inline-docs\": {
                  \"status\": \"${{ steps.stage1.outputs.stage1_status || 'skipped' }}\",
                  \"files_generated\": ${{ steps.stage1.outputs.stage1_files || 0 }}
                }
              }
            }" || echo "‚ö†Ô∏è Stage 1 progress notification failed (non-blocking)"

      # =========================================================================
      # STAGE 2: CODEWIKI ANALYSIS
      # Generate architecture overview and module tree
      # =========================================================================

      # Detect primary language to determine if CodeWiki is supported
      # CodeWiki only supports: Python, Java, JavaScript, TypeScript, C, C++, C#
      # For Go/Rust, we use Claude-based architecture analysis instead
      - name: Detect Repository Language
        id: detect_language
        if: contains(env.STAGES, 'codewiki')
        run: |
          echo "üîç Detecting repository primary language..."

          # Count source files by extension (excluding node_modules, vendor, etc.)
          GO_COUNT=$(find . -name "*.go" -type f -not -path "*/node_modules/*" -not -path "*/vendor/*" | wc -l | tr -d ' ')
          RUST_COUNT=$(find . -name "*.rs" -type f -not -path "*/target/*" | wc -l | tr -d ' ')
          PY_COUNT=$(find . -name "*.py" -type f -not -path "*/.venv/*" -not -path "*/venv/*" | wc -l | tr -d ' ')
          JAVA_COUNT=$(find . -name "*.java" -type f | wc -l | tr -d ' ')
          TS_COUNT=$(find . -name "*.ts" -name "*.tsx" -type f -not -path "*/node_modules/*" | wc -l | tr -d ' ')
          JS_COUNT=$(find . -name "*.js" -name "*.jsx" -type f -not -path "*/node_modules/*" | wc -l | tr -d ' ')
          C_COUNT=$(find . -name "*.c" -name "*.cpp" -name "*.h" -type f | wc -l | tr -d ' ')
          CS_COUNT=$(find . -name "*.cs" -type f | wc -l | tr -d ' ')

          echo "üìä File counts:"
          echo "  Go: $GO_COUNT"
          echo "  Rust: $RUST_COUNT"
          echo "  Python: $PY_COUNT"
          echo "  Java: $JAVA_COUNT"
          echo "  TypeScript: $TS_COUNT"
          echo "  JavaScript: $JS_COUNT"
          echo "  C/C++: $C_COUNT"
          echo "  C#: $CS_COUNT"

          # Determine primary language based on file count
          # Priority: Go/Rust first (they need alternative), then supported languages
          if [ "$GO_COUNT" -gt 0 ]; then
            PRIMARY_LANG="go"
            CODEWIKI_SUPPORTED="false"
            echo "üì¶ Primary language: Go (CodeWiki NOT supported)"
          elif [ "$RUST_COUNT" -gt 0 ]; then
            PRIMARY_LANG="rust"
            CODEWIKI_SUPPORTED="false"
            echo "üì¶ Primary language: Rust (CodeWiki NOT supported)"
          elif [ "$PY_COUNT" -gt 0 ]; then
            PRIMARY_LANG="python"
            CODEWIKI_SUPPORTED="true"
            echo "üì¶ Primary language: Python (CodeWiki supported)"
          elif [ "$JAVA_COUNT" -gt 0 ]; then
            PRIMARY_LANG="java"
            CODEWIKI_SUPPORTED="true"
            echo "üì¶ Primary language: Java (CodeWiki supported)"
          elif [ "$TS_COUNT" -gt 0 ]; then
            PRIMARY_LANG="typescript"
            CODEWIKI_SUPPORTED="true"
            echo "üì¶ Primary language: TypeScript (CodeWiki supported)"
          elif [ "$JS_COUNT" -gt 0 ]; then
            PRIMARY_LANG="javascript"
            CODEWIKI_SUPPORTED="true"
            echo "üì¶ Primary language: JavaScript (CodeWiki supported)"
          elif [ "$C_COUNT" -gt 0 ]; then
            PRIMARY_LANG="c"
            CODEWIKI_SUPPORTED="true"
            echo "üì¶ Primary language: C/C++ (CodeWiki supported)"
          elif [ "$CS_COUNT" -gt 0 ]; then
            PRIMARY_LANG="csharp"
            CODEWIKI_SUPPORTED="true"
            echo "üì¶ Primary language: C# (CodeWiki supported)"
          else
            PRIMARY_LANG="unknown"
            CODEWIKI_SUPPORTED="true"
            echo "üì¶ Primary language: Unknown (will try CodeWiki)"
          fi

          echo "primary_language=$PRIMARY_LANG" >> $GITHUB_OUTPUT
          echo "codewiki_supported=$CODEWIKI_SUPPORTED" >> $GITHUB_OUTPUT

      - name: Setup Python 3.12
        if: contains(env.STAGES, 'codewiki') && steps.detect_language.outputs.codewiki_supported == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install CodeWiki
        id: codewiki_install
        if: contains(env.STAGES, 'codewiki') && steps.detect_language.outputs.codewiki_supported == 'true'
        continue-on-error: true
        run: |
          # Install keyrings.alt for headless keyring support in CI environments
          pip install keyrings.alt
          pip install git+https://github.com/FSoft-AI4Code/CodeWiki.git
          echo "codewiki_installed=true" >> $GITHUB_OUTPUT

      - name: Configure CodeWiki
        id: codewiki_config
        if: contains(env.STAGES, 'codewiki') && steps.detect_language.outputs.codewiki_supported == 'true' && steps.codewiki_install.outputs.codewiki_installed == 'true'
        continue-on-error: true
        env:
          # SECURITY: Pass secrets per-step with inline masking
          OPENAI_API_KEY: ${{ github.event.client_payload.openai_api_key || github.event.inputs.openai_api_key || '' }}
          ANTHROPIC_API_KEY: ${{ github.event.client_payload.anthropic_api_key || github.event.inputs.anthropic_api_key || '' }}
          # Set keyring backend via env var (must be set before any keyring operations)
          PYTHON_KEYRING_BACKEND: keyrings.alt.file.PlaintextKeyring
        run: |
          # SECURITY: Mask secrets immediately before any echo
          if [ -n "$OPENAI_API_KEY" ]; then
            echo "::add-mask::$OPENAI_API_KEY"
          fi
          if [ -n "$ANTHROPIC_API_KEY" ]; then
            echo "::add-mask::$ANTHROPIC_API_KEY"
          fi

          # === KEYRING CONFIGURATION FOR CI ===
          # CodeWiki stores API keys in system keyring. In CI (no GUI), we must:
          # 1. Create keyring config to specify PlaintextKeyring backend
          # 2. Create data directory for credential storage
          # See: https://github.com/FSoft-AI4Code/CodeWiki - uses keyring.set_password()

          echo "üîë Setting up keyring for headless CI environment..."

          # Create keyring configuration directory and config file
          mkdir -p ~/.config/python_keyring
          cat > ~/.config/python_keyring/keyringrc.cfg << 'KEYRING_CFG'
          [backend]
          default-keyring=keyrings.alt.file.PlaintextKeyring
          KEYRING_CFG

          # Ensure keyring data directory exists with proper permissions
          mkdir -p ~/.local/share/python_keyring
          chmod 700 ~/.local/share/python_keyring

          # Debug: Verify keyring is properly configured
          echo "üìã Keyring backend verification:"
          python3 -c "import keyring; print(f'  Active backend: {keyring.get_keyring()}')"

          # Configure CodeWiki with selected provider and model
          # Supported providers: anthropic (recommended), openai
          # See: https://fsoft-ai4code.github.io/CodeWiki/
          echo "üîß Configuring CodeWiki with provider: $CODEWIKI_PROVIDER, model: $CODEWIKI_MODEL"

          if [ "$CODEWIKI_PROVIDER" = "anthropic" ]; then
            # Anthropic Claude - CodeWiki's recommended provider (68.79% quality score)
            codewiki config set \
              --api-key "$ANTHROPIC_API_KEY" \
              --base-url "https://api.anthropic.com" \
              --main-model "$CODEWIKI_MODEL" \
              --cluster-model "$CODEWIKI_MODEL"
          else
            # OpenAI - fallback option
            codewiki config set \
              --api-key "$OPENAI_API_KEY" \
              --base-url "https://api.openai.com/v1" \
              --main-model "$CODEWIKI_MODEL" \
              --cluster-model "${CODEWIKI_MODEL}-mini"
          fi

          # Verify configuration was saved
          echo ""
          echo "üìã CodeWiki configuration:"
          codewiki config show

          echo ""
          echo "‚úÖ Validating configuration..."
          codewiki config validate

          echo ""
          echo "codewiki_configured=true" >> $GITHUB_OUTPUT

      - name: Run CodeWiki Analysis
        id: stage2
        if: contains(env.STAGES, 'codewiki') && steps.detect_language.outputs.codewiki_supported == 'true' && steps.codewiki_config.outputs.codewiki_configured == 'true'
        continue-on-error: false
        env:
          # Keyring backend for CI (must match config step)
          PYTHON_KEYRING_BACKEND: keyrings.alt.file.PlaintextKeyring
          # API keys for both providers (CodeWiki will use the one configured)
          OPENAI_API_KEY: ${{ github.event.client_payload.openai_api_key || github.event.inputs.openai_api_key || '' }}
          ANTHROPIC_API_KEY: ${{ github.event.client_payload.anthropic_api_key || github.event.inputs.anthropic_api_key || '' }}
        run: |
          # SECURITY: Mask secrets immediately
          if [ -n "$OPENAI_API_KEY" ]; then
            echo "::add-mask::$OPENAI_API_KEY"
          fi
          if [ -n "$ANTHROPIC_API_KEY" ]; then
            echo "::add-mask::$ANTHROPIC_API_KEY"
          fi

          echo "üìä Stage 2: Running CodeWiki analysis..."

          # Debug: Show active keyring backend
          echo "üìã Keyring verification before generate:"
          python3 -c "import keyring; print(f'  Active backend: {keyring.get_keyring()}')"

          # IMPORTANT: Exclude dependency directories from CodeWiki analysis
          # CodeWiki analyzes ALL code in the directory, including node_modules/vendor
          # which can result in documenting dependencies instead of the actual project
          # NOTE: Do NOT exclude .git - CodeWiki needs it for git features
          echo "üóÇÔ∏è Excluding dependency directories from CodeWiki analysis..."
          EXCLUDED_DIRS=""
          for dir in node_modules vendor .venv venv __pycache__ dist build .next target; do
            if [ -d "$dir" ]; then
              echo "  Moving $dir to /tmp/codewiki_excluded_$dir"
              mv "$dir" "/tmp/codewiki_excluded_$dir"
              EXCLUDED_DIRS="$EXCLUDED_DIRS $dir"
            fi
          done

          # Also exclude helper/utility scripts that aren't part of the main codebase
          # These are typically standalone scripts for CI/CD, code generation, etc.
          echo "üóÇÔ∏è Excluding helper scripts from CodeWiki analysis..."
          EXCLUDED_FILES=""
          for file in generate-inline-docs.js generate-docs.js; do
            if [ -f "$file" ]; then
              echo "  Moving $file to /tmp/codewiki_excluded_$file"
              mv "$file" "/tmp/codewiki_excluded_$file"
              EXCLUDED_FILES="$EXCLUDED_FILES $file"
            fi
          done

          # Show what CodeWiki will analyze
          echo "üìÇ Files/directories to analyze:"
          ls -la | head -20

          mkdir -p docs/codewiki

          # Run CodeWiki with verbose output - fail if it fails
          codewiki generate --output ./docs/codewiki --verbose

          # Restore excluded directories (for subsequent steps)
          for dir in $EXCLUDED_DIRS; do
            if [ -d "/tmp/codewiki_excluded_$dir" ]; then
              echo "  Restoring $dir"
              mv "/tmp/codewiki_excluded_$dir" "$dir"
            fi
          done

          # Restore excluded files
          for file in $EXCLUDED_FILES; do
            if [ -f "/tmp/codewiki_excluded_$file" ]; then
              echo "  Restoring $file"
              mv "/tmp/codewiki_excluded_$file" "$file"
            fi
          done

          CODEWIKI_FILES=$(find docs/codewiki -name "*.md" -type f 2>/dev/null | wc -l)
          echo "stage2_files=$CODEWIKI_FILES" >> $GITHUB_OUTPUT
          echo "stage2_status=completed" >> $GITHUB_OUTPUT

      # Alternative: Claude Architecture Analysis for Go/Rust (when CodeWiki is not supported)
      - name: Run Claude Architecture Analysis (Go/Rust)
        id: stage2_alt
        if: contains(env.STAGES, 'codewiki') && steps.detect_language.outputs.codewiki_supported == 'false'
        env:
          ANTHROPIC_API_KEY: ${{ github.event.client_payload.anthropic_api_key || github.event.inputs.anthropic_api_key || '' }}
          PRIMARY_LANGUAGE: ${{ steps.detect_language.outputs.primary_language }}
        run: |
          # SECURITY: Mask API key
          if [ -n "$ANTHROPIC_API_KEY" ]; then
            echo "::add-mask::$ANTHROPIC_API_KEY"
          fi

          echo "üìä Stage 2 (Alternative): Claude Architecture Analysis for $PRIMARY_LANGUAGE..."

          # Create output directory
          mkdir -p docs/codewiki

          # Collect source files based on language
          echo "üìÅ Collecting source files..."
          if [ "$PRIMARY_LANGUAGE" = "go" ]; then
            SOURCE_FILES=$(find . -name "*.go" -type f -not -path "*/vendor/*" | head -50)
          elif [ "$PRIMARY_LANGUAGE" = "rust" ]; then
            SOURCE_FILES=$(find . -name "*.rs" -type f -not -path "*/target/*" | head -50)
          else
            SOURCE_FILES=$(find . -type f \( -name "*.go" -o -name "*.rs" \) | head -50)
          fi

          FILE_COUNT=$(echo "$SOURCE_FILES" | wc -l | tr -d ' ')
          echo "  Found $FILE_COUNT source files to analyze"

          # Build file contents for Claude
          FILE_CONTENTS=""
          for file in $SOURCE_FILES; do
            if [ -f "$file" ]; then
              FILE_CONTENTS="$FILE_CONTENTS

--- File: $file ---
$(head -200 "$file")"
            fi
          done

          # Get repository name from current directory
          REPO_NAME=$(basename "$(pwd)")

          # Also include README if it exists
          README_CONTENT=""
          if [ -f "README.md" ]; then
            README_CONTENT="--- README.md ---
$(cat README.md)"
          fi

          # Call Claude API to generate architecture documentation
          echo "ü§ñ Calling Claude API for architecture analysis..."

          RESPONSE=$(curl -s -X POST "https://api.anthropic.com/v1/messages" \
            -H "Content-Type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d "$(cat <<EOF
{
  "model": "claude-sonnet-4-20250514",
  "max_tokens": 8000,
  "messages": [
    {
      "role": "user",
      "content": "You are an expert software architect. Analyze this $PRIMARY_LANGUAGE repository and generate comprehensive architecture documentation.\n\nRepository: $REPO_NAME\nPrimary Language: $PRIMARY_LANGUAGE\n\n$README_CONTENT\n\nSource Files:\n$FILE_CONTENTS\n\nGenerate documentation in Markdown format with:\n1. **Overview**: What this project does (2-3 sentences)\n2. **Architecture**: High-level system design\n3. **Core Components**: Key modules/packages and their responsibilities\n4. **Component Relationships**: Mermaid flowchart diagram showing dependencies\n5. **Data Flow**: How data moves through the system (Mermaid sequence diagram)\n6. **Key Files**: Most important files and their purpose\n7. **CLI Commands**: (if applicable) Available commands and usage\n\nIMPORTANT: Focus ONLY on the actual $PRIMARY_LANGUAGE code. Do NOT document helper scripts (like .js files) unless they are part of the core functionality. The documentation should describe what THIS repository does, not any helper tools.\n\nOutput only the Markdown documentation, no preamble."
    }
  ]
}
EOF
)")

          # Extract the content from Claude's response
          CONTENT=$(echo "$RESPONSE" | node -e "
            const data = JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8'));
            if (data.content && data.content[0] && data.content[0].text) {
              console.log(data.content[0].text);
            } else if (data.error) {
              console.error('API Error:', data.error.message);
              process.exit(1);
            } else {
              console.error('Unexpected response:', JSON.stringify(data));
              process.exit(1);
            }
          ")

          if [ $? -ne 0 ]; then
            echo "‚ùå Claude API call failed"
            echo "$RESPONSE"
            echo "stage2_files=0" >> $GITHUB_OUTPUT
            echo "stage2_status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Write the documentation
          echo "# $REPO_NAME Module Documentation" > docs/codewiki/overview.md
          echo "" >> docs/codewiki/overview.md
          echo "$CONTENT" >> docs/codewiki/overview.md

          # Also create metadata.json for consistency with CodeWiki output
          cat > docs/codewiki/metadata.json << METADATA
{
  "generator": "claude-architecture-analysis",
  "model": "claude-sonnet-4-20250514",
  "language": "$PRIMARY_LANGUAGE",
  "files_analyzed": $FILE_COUNT,
  "generated_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
}
METADATA

          echo "‚úÖ Architecture documentation generated successfully"
          echo "  Output: docs/codewiki/overview.md"

          ARCH_FILES=$(find docs/codewiki -name "*.md" -type f 2>/dev/null | wc -l)
          echo "stage2_files=$ARCH_FILES" >> $GITHUB_OUTPUT
          echo "stage2_status=completed" >> $GITHUB_OUTPUT

      - name: Report Stage 2 Progress
        if: always() && contains(env.STAGES, 'codewiki') && env.CALLBACK_URL != ''
        continue-on-error: true
        env:
          WEBHOOK_SECRET: ${{ github.event.client_payload.webhook_secret || github.event.inputs.webhook_secret || '' }}
        run: |
          if [ -n "$WEBHOOK_SECRET" ]; then
            echo "::add-mask::$WEBHOOK_SECRET"
          fi

          echo "üì§ Reporting Stage 2 (Architecture Analysis) completion..."

          # Use outputs from either CodeWiki (stage2) or Claude alternative (stage2_alt)
          STAGE2_STATUS="${{ steps.stage2.outputs.stage2_status || steps.stage2_alt.outputs.stage2_status || 'skipped' }}"
          STAGE2_FILES="${{ steps.stage2.outputs.stage2_files || steps.stage2_alt.outputs.stage2_files || 0 }}"

          curl -s -o /dev/null -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $WEBHOOK_SECRET" \
            -d "{
              \"run_id\": \"$RUN_ID\",
              \"repo_id\": \"$REPO_ID\",
              \"status\": \"running\",
              \"workflow_run_id\": ${{ github.run_id }},
              \"workflow_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
              \"current_stage\": \"voltagent\",
              \"stage_results\": {
                \"inline-docs\": {
                  \"status\": \"${{ steps.stage1.outputs.stage1_status || 'skipped' }}\",
                  \"files_generated\": ${{ steps.stage1.outputs.stage1_files || 0 }}
                },
                \"codewiki\": {
                  \"status\": \"$STAGE2_STATUS\",
                  \"files_generated\": $STAGE2_FILES
                }
              }
            }" || echo "‚ö†Ô∏è Stage 2 progress notification failed (non-blocking)"

      # =========================================================================
      # STAGE 3: VOLTAGENT TUTORIALS
      # Generate getting started guides and how-to tutorials
      # =========================================================================
      - name: Install VoltAgent Dependencies
        if: contains(env.STAGES, 'voltagent')
        run: |
          npm install @anthropic-ai/sdk glob

      - name: Generate Tutorials with AI
        id: stage3
        if: contains(env.STAGES, 'voltagent')
        env:
          # SECURITY: Pass secret per-step with inline masking
          ANTHROPIC_API_KEY: ${{ github.event.client_payload.anthropic_api_key || github.event.inputs.anthropic_api_key || '' }}
        run: |
          # SECURITY: Mask secret immediately before any echo
          if [ -n "$ANTHROPIC_API_KEY" ]; then
            echo "::add-mask::$ANTHROPIC_API_KEY"
          fi

          echo "üìö Stage 3: Generating tutorials..."

          cat > generate-tutorials.js << 'SCRIPT_EOF'
          #!/usr/bin/env node
          const Anthropic = require('@anthropic-ai/sdk');
          const fs = require('fs').promises;
          const path = require('path');
          const { glob } = require('glob');

          const client = new Anthropic.default();

          async function gatherContext() {
            const context = { readme: '', claudeMd: '', inlineDocs: [], codewiki: [] };

            // Read README
            try {
              context.readme = await fs.readFile('README.md', 'utf-8');
            } catch {}

            // Read CLAUDE.md
            try {
              context.claudeMd = await fs.readFile('CLAUDE.md', 'utf-8');
            } catch {}

            // Gather inline docs from Stage 1
            const inlineMdFiles = await glob('src/**/*.md');
            for (const file of inlineMdFiles.slice(0, 20)) {
              try {
                const content = await fs.readFile(file, 'utf-8');
                context.inlineDocs.push({ path: file, content: content.slice(0, 1000) });
              } catch {}
            }

            // Gather CodeWiki docs from Stage 2
            const codewikiFiles = await glob('docs/codewiki/**/*.md');
            for (const file of codewikiFiles.slice(0, 10)) {
              try {
                const content = await fs.readFile(file, 'utf-8');
                context.codewiki.push({ path: file, content: content.slice(0, 2000) });
              } catch {}
            }

            return context;
          }

          async function generateTutorial(title, prompt, context, outputPath) {
            console.log(`  üìù Generating: ${title}...`);

            const contextSummary = `
          PROJECT CONTEXT:
          ${context.readme.slice(0, 3000)}

          ${context.claudeMd ? `PROJECT INSTRUCTIONS (CLAUDE.md):\n${context.claudeMd.slice(0, 2000)}` : ''}

          INLINE DOCUMENTATION (${context.inlineDocs.length} files):
          ${context.inlineDocs.map(d => `- ${d.path}`).join('\n')}

          CODEWIKI DOCUMENTATION (${context.codewiki.length} files):
          ${context.codewiki.map(d => `- ${d.path}`).join('\n')}
          `;

            const response = await client.messages.create({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 4096,
              system: `You are a technical writer creating developer documentation.
          Write clear, practical documentation that developers can follow step-by-step.
          Use Markdown formatting with proper headings, code blocks, and examples.
          Be concise but thorough. Include real code examples when helpful.`,
              messages: [{
                role: 'user',
                content: `${prompt}\n\n${contextSummary}`
              }]
            });

            const content = response.content[0].text;
            await fs.mkdir(path.dirname(outputPath), { recursive: true });
            await fs.writeFile(outputPath, content);
            console.log(`  ‚úÖ Written: ${outputPath}`);
            return outputPath;
          }

          async function main() {
            console.log('üîç Gathering project context...');
            const context = await gatherContext();

            console.log(`  README: ${context.readme.length} chars`);
            console.log(`  CLAUDE.md: ${context.claudeMd.length} chars`);
            console.log(`  Inline docs: ${context.inlineDocs.length} files`);
            console.log(`  CodeWiki docs: ${context.codewiki.length} files`);

            const tutorials = [
              {
                title: 'Getting Started',
                outputPath: 'docs/tutorials/getting-started.md',
                prompt: `Write a "Getting Started" guide for this project.
          Include:
          1. Prerequisites (what needs to be installed)
          2. Installation steps
          3. Basic configuration
          4. Running the project locally
          5. First steps / "Hello World" equivalent
          6. Common issues and solutions

          Make it beginner-friendly but assume the reader knows basic programming.`
              },
              {
                title: 'Architecture Overview',
                outputPath: 'docs/tutorials/architecture-overview.md',
                prompt: `Write an "Architecture Overview" document for this project.
          Include:
          1. High-level architecture diagram description (describe what a diagram would show)
          2. Main components and their responsibilities
          3. Data flow between components
          4. Key design decisions and patterns used
          5. Directory/folder structure explanation

          Focus on helping new developers understand the codebase structure.`
              },
              {
                title: 'API Examples',
                outputPath: 'docs/tutorials/api-examples.md',
                prompt: `Write an "API Usage Examples" guide for this project.
          Include:
          1. Main API endpoints or functions available
          2. Authentication (if applicable)
          3. Common use cases with code examples
          4. Error handling patterns
          5. Best practices

          Include practical, copy-paste ready code examples.`
              }
            ];

            let generated = 0;
            for (const tutorial of tutorials) {
              try {
                await generateTutorial(
                  tutorial.title,
                  tutorial.prompt,
                  context,
                  tutorial.outputPath
                );
                generated++;
                // Rate limiting
                await new Promise(r => setTimeout(r, 1000));
              } catch (error) {
                console.error(`  ‚ùå Failed: ${tutorial.title}:`, error.message);
              }
            }

            console.log(`\nüìä Stage 3 Complete:`);
            console.log(`   Generated: ${generated} tutorials`);

            await fs.writeFile('.doc-stage3-stats.json', JSON.stringify({
              generated, timestamp: new Date().toISOString()
            }));
          }

          main().catch(err => {
            console.error('Stage 3 failed:', err);
            process.exit(1);
          });
          SCRIPT_EOF

          node generate-tutorials.js

          TUTORIAL_FILES=$(find docs/tutorials -name "*.md" -type f 2>/dev/null | wc -l)
          echo "stage3_files=$TUTORIAL_FILES" >> $GITHUB_OUTPUT
          echo "stage3_status=completed" >> $GITHUB_OUTPUT

      - name: Report Stage 3 Progress
        if: always() && contains(env.STAGES, 'voltagent') && env.CALLBACK_URL != ''
        continue-on-error: true
        env:
          WEBHOOK_SECRET: ${{ github.event.client_payload.webhook_secret || github.event.inputs.webhook_secret || '' }}
        run: |
          if [ -n "$WEBHOOK_SECRET" ]; then
            echo "::add-mask::$WEBHOOK_SECRET"
          fi

          echo "üì§ Reporting Stage 3 (VoltAgent) completion..."

          curl -s -o /dev/null -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $WEBHOOK_SECRET" \
            -d "{
              \"run_id\": \"$RUN_ID\",
              \"repo_id\": \"$REPO_ID\",
              \"status\": \"running\",
              \"workflow_run_id\": ${{ github.run_id }},
              \"workflow_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
              \"current_stage\": \"creating-pr\",
              \"stage_results\": {
                \"inline-docs\": {
                  \"status\": \"${{ steps.stage1.outputs.stage1_status || 'skipped' }}\",
                  \"files_generated\": ${{ steps.stage1.outputs.stage1_files || 0 }}
                },
                \"codewiki\": {
                  \"status\": \"${{ steps.stage2.outputs.stage2_status || 'skipped' }}\",
                  \"files_generated\": ${{ steps.stage2.outputs.stage2_files || 0 }}
                },
                \"voltagent\": {
                  \"status\": \"${{ steps.stage3.outputs.stage3_status || 'skipped' }}\",
                  \"files_generated\": ${{ steps.stage3.outputs.stage3_files || 0 }}
                }
              }
            }" || echo "‚ö†Ô∏è Stage 3 progress notification failed (non-blocking)"

      # =========================================================================
      # CREATE PULL REQUEST
      # =========================================================================
      - name: Cleanup Temporary Files
        run: |
          echo "üßπ Cleaning up temporary files before PR creation..."

          # Remove generated scripts (created with heredoc)
          rm -f generate-inline-docs.js
          rm -f generate-tutorials.js

          # Remove stats files
          rm -f .doc-stage1-stats.json
          rm -f .doc-stage3-stats.json

          # Remove npm artifacts (installed for scripts)
          rm -rf node_modules
          rm -f package.json
          rm -f package-lock.json

          echo "‚úÖ Cleanup complete"

      - name: Sanitize Branch Name
        id: branch-name
        run: |
          # Replace colons and other invalid chars with hyphens for git branch name
          SAFE_RUN_ID=$(echo "$RUN_ID" | sed 's/[:]/-/g' | sed 's/[^a-zA-Z0-9._-]/-/g')
          echo "safe_run_id=$SAFE_RUN_ID" >> $GITHUB_OUTPUT
          echo "üìù Sanitized RUN_ID for branch: $SAFE_RUN_ID"

      - name: Stage Generated Documentation
        id: stage-docs
        run: |
          echo "üìÅ Staging generated documentation files..."

          # Count files before staging
          BEFORE_COUNT=$(git status --porcelain | wc -l)
          echo "   Files to stage: $BEFORE_COUNT"

          # Stage all generated .md files (documentation)
          git add -f docs/**/*.md 2>/dev/null || true
          git add -f src/**/*.md 2>/dev/null || true
          git add -f lib/**/*.md 2>/dev/null || true
          git add -f app/**/*.md 2>/dev/null || true
          git add -f components/**/*.md 2>/dev/null || true
          git add -f hooks/**/*.md 2>/dev/null || true
          git add -f utils/**/*.md 2>/dev/null || true
          git add -f crates/**/*.md 2>/dev/null || true
          git add -f cli/**/*.md 2>/dev/null || true
          git add -f bin/**/*.md 2>/dev/null || true
          git add -f cmd/**/*.md 2>/dev/null || true
          git add -f internal/**/*.md 2>/dev/null || true
          git add -f pkg/**/*.md 2>/dev/null || true
          git add -f api/**/*.md 2>/dev/null || true

          # Stage root-level .md files (except README.md to avoid conflicts)
          for f in *.md; do
            if [ -f "$f" ] && [ "$f" != "README.md" ] && [ "$f" != "CHANGELOG.md" ]; then
              git add -f "$f" 2>/dev/null || true
            fi
          done

          # Count staged files
          STAGED_COUNT=$(git diff --cached --name-only | wc -l)
          echo "   Staged files: $STAGED_COUNT"
          echo "staged_count=$STAGED_COUNT" >> $GITHUB_OUTPUT

          # Show what was staged
          echo ""
          echo "üìã Staged files:"
          git diff --cached --name-only | head -50

          if [ "$STAGED_COUNT" -eq "0" ]; then
            echo ""
            echo "‚ö†Ô∏è No documentation files to stage"
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Create Pull Request
        if: steps.stage-docs.outputs.has_changes == 'true'
        id: create-pr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            docs: Automated documentation update [skip ci]

            Generated by Doc Orchestrator Pipeline
            Run ID: ${{ env.RUN_ID }}
          title: "üìö Automated Documentation Update"
          body: |
            ## Documentation Pipeline Results

            **Run ID:** `${{ env.RUN_ID }}`

            ### Stage 1: Inline Documentation
            - Status: ${{ steps.stage1.outputs.stage1_status || 'skipped' }}
            - Files generated: ${{ steps.stage1.outputs.stage1_files || '0' }}
            - Generated `.md` files next to source classes explaining their purpose

            ### Stage 2: CodeWiki Analysis
            - Status: ${{ steps.stage2.outputs.stage2_status || 'skipped' }}
            - Files generated: ${{ steps.stage2.outputs.stage2_files || '0' }}
            - Architecture overview and module documentation

            ### Stage 3: VoltAgent Tutorials
            - Status: ${{ steps.stage3.outputs.stage3_status || 'skipped' }}
            - Files generated: ${{ steps.stage3.outputs.stage3_files || '0' }}
            - Getting started guides and how-to tutorials

            ---

            **Review checklist:**
            - [ ] Check generated inline docs for accuracy
            - [ ] Review architecture documentation
            - [ ] Test code examples in tutorials

            ---
            ü§ñ Generated by [Doc Orchestrator](https://github.com/openframe-oss-tenant)
          branch: docs/orchestrator-${{ steps.branch-name.outputs.safe_run_id }}
          base: ${{ github.event.repository.default_branch }}
          delete-branch: true
          labels: |
            documentation
            automated
          # Only include documentation files in the PR - excludes temp scripts, node_modules, etc.
          add-paths: |
            docs/**
            src/**/*.md
            lib/**/*.md
            app/**/*.md
            components/**/*.md
            hooks/**/*.md
            utils/**/*.md
            crates/**/*.md
            cli/**/*.md
            bin/**/*.md
            cmd/**/*.md
            internal/**/*.md
            pkg/**/*.md
            api/**/*.md
            *.md

      # =========================================================================
      # SEND WEBHOOK NOTIFICATION
      # =========================================================================
      - name: Send Webhook Notification
        if: always() && env.CALLBACK_URL != ''
        continue-on-error: true  # Don't fail the workflow if callback fails
        env:
          # SECURITY: Pass secret per-step with inline masking
          WEBHOOK_SECRET: ${{ github.event.client_payload.webhook_secret || github.event.inputs.webhook_secret || '' }}
        run: |
          # SECURITY: Mask secret immediately before any echo
          if [ -n "$WEBHOOK_SECRET" ]; then
            echo "::add-mask::$WEBHOOK_SECRET"
          fi

          echo "üì§ Sending webhook to: $CALLBACK_URL"

          # Determine overall status
          if [ "${{ steps.stage-docs.outputs.has_changes }}" != "true" ]; then
            STATUS="no_changes"
            echo "   Status: no_changes (no documentation files generated)"
          elif [ "${{ job.status }}" = "success" ]; then
            STATUS="success"
          else
            STATUS="failure"
          fi

          # Build stage results JSON
          STAGE_RESULTS=$(cat << EOF
          {
            "inline_docs": {
              "status": "${{ steps.stage1.outputs.stage1_status || 'skipped' }}",
              "files_generated": ${{ steps.stage1.outputs.stage1_files || 0 }}
            },
            "codewiki": {
              "status": "${{ steps.stage2.outputs.stage2_status || 'skipped' }}",
              "files_generated": ${{ steps.stage2.outputs.stage2_files || 0 }}
            },
            "voltagent": {
              "status": "${{ steps.stage3.outputs.stage3_status || 'skipped' }}",
              "files_generated": ${{ steps.stage3.outputs.stage3_files || 0 }}
            }
          }
          EOF
          )

          # Get sanitized branch name
          SAFE_BRANCH="docs/orchestrator-${{ steps.branch-name.outputs.safe_run_id }}"

          # Send webhook (don't fail if it doesn't work)
          HTTP_CODE=$(curl -s -o /tmp/webhook_response.txt -w "%{http_code}" -X POST "$CALLBACK_URL" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer $WEBHOOK_SECRET" \
            -d "{
              \"run_id\": \"$RUN_ID\",
              \"repo_id\": \"$REPO_ID\",
              \"status\": \"$STATUS\",
              \"workflow_run_id\": ${{ github.run_id }},
              \"workflow_url\": \"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\",
              \"pr_url\": \"${{ steps.create-pr.outputs.pull-request-url }}\",
              \"pr_number\": ${{ steps.create-pr.outputs.pull-request-number || 'null' }},
              \"branch\": \"$SAFE_BRANCH\",
              \"stage_results\": $STAGE_RESULTS
            }") || HTTP_CODE="failed"

          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "201" ]; then
            echo "‚úÖ Webhook sent successfully (HTTP $HTTP_CODE)"
          else
            echo "‚ö†Ô∏è Webhook notification returned HTTP $HTTP_CODE (non-blocking)"
            cat /tmp/webhook_response.txt 2>/dev/null || true
          fi

      - name: Pipeline Summary
        if: always()
        run: |
          echo "## üìö Doc Orchestrator Pipeline Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status | Files |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Inline Docs | ${{ steps.stage1.outputs.stage1_status || 'skipped' }} | ${{ steps.stage1.outputs.stage1_files || '0' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| CodeWiki | ${{ steps.stage2.outputs.stage2_status || 'skipped' }} | ${{ steps.stage2.outputs.stage2_files || '0' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Tutorials | ${{ steps.stage3.outputs.stage3_status || 'skipped' }} | ${{ steps.stage3.outputs.stage3_files || '0' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ steps.create-pr.outputs.pull-request-url }}" ]; then
            echo "**Pull Request:** ${{ steps.create-pr.outputs.pull-request-url }}" >> $GITHUB_STEP_SUMMARY
          fi
